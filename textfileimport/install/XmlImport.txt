'VERSION 1.0 CLASS
'BEGIN
 ' MultiUse = -1  'True
'End
Option Explicit

'Version: 3.1

Private WithEvents m_WorkDialog As LCO.WorkDialog
Private m_pCoworkers As LDE.Records
Private m_pXmlDocument  As MSXML2.DOMDocument60
Private m_pSettings As MSXML2.DOMDocument60
Private m_sImportFile As String
Private m_lngSubLimeID As Long
Private m_lngMainLimeID As Long
Private Const INTEXECUTESTEP As Integer = 100
Private m_dblRaiseProgressImportSteps As Double
Private m_dblRaiseProgresCheckSteps As Double
Private Const STRLOGFILEPATH As String = "apps\textfileimport\src\"
Private m_lngCoworkerRandomizedNumber As Long
Private m_lngFilterHits As Long
Private m_lngFileHits As Long

'-------------------------------------------
' ##SUMMARY Updates the workdialog text
'-------------------------------------------
Private Sub SetWorkDialogText(strID As String, Optional strValue1 As String = "", Optional strValue2 As String = "", Optional strValue3 As String = "")
    On Error Resume Next

    m_WorkDialog.Text = Application.GetText("textfileimport", strID, "workDialog", strValue1, strValue2, strValue3)
    
    DoEvents
    DoEvents
End Sub

'-------------------------------------------
' ##SUMMARY Updates the workdialog progressbar
'-------------------------------------------
Private Sub SetWorkDialogProgressBar(Optional dblRaiseWith As Double = 0, Optional intProgressStatus As Integer = -1)
    On Error Resume Next

    If intProgressStatus > 0 Then
        m_WorkDialog.Progress = intProgressStatus
    Else
        m_WorkDialog.Progress = m_WorkDialog.Progress + dblRaiseWith
    End If

    DoEvents
    DoEvents
End Sub

'-----------------------------------------------
' ##SUMMARY Set general settings for global WorkDialog
'-----------------------------------------------
Private Sub SetWorkDialogSettings(blnOnTop As Boolean, blnShowCancel As Boolean)
    On Error GoTo ErrorHandler
    If blnShowCancel Then
        m_WorkDialog.Style = lcoShowProgressBar + lcoShowText + lcoShowIcon + lcoShowCancelButton
        m_WorkDialog.CancelText = Application.GetText("textfileimport", "cancelButton", "workDialog")
    Else
        m_WorkDialog.Style = lcoShowProgressBar + lcoShowText + lcoShowIcon
    End If

    m_WorkDialog.Caption = Application.GetText("textfileimport", "caption", "workDialog")

    If blnOnTop Then
        m_WorkDialog.Style = m_WorkDialog.Style + lcoShowTopMost
    End If

    DoEvents

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "SyncRecovery::SetWorkDialogSettings" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Sub AppendFileColumns(ByVal pXml As MSXML2.DOMDocument60, strFileFormat As String, strTextQualifier As String)
    On Error GoTo ErrorHandler
    Dim pFso As Scripting.FileSystemObject
    Dim pStream As Scripting.TextStream
    Dim pColumns As Scripting.Dictionary
    Dim pColumnsNode As MSXML2.IXMLDOMElement
    Dim sColumnsLine As String
    Dim arrColumns() As String
    Dim nIndex As Integer
    Dim strDelimiter As String

    Set pFso = New Scripting.FileSystemObject
    Set pStream = pFso.OpenTextFile(m_sImportFile, ForReading)
    sColumnsLine = pStream.ReadLine
    Call pStream.Close

    If InStr(1, sColumnsLine, ".") > 0 Or InStr(1, sColumnsLine, "[") > 0 Or InStr(1, sColumnsLine, "]") > 0 Then
        Call UI.ShowError(Application.GetText("textfileimport", "invalidColumnNames", "xmlImport"))
    End If

    Select Case strFileFormat
        Case "TabDelimited":
            strDelimiter = vbTab
        Case "CSVDelimited":
            strDelimiter = ","
        Case Else:
            strDelimiter = strFileFormat
    End Select

    arrColumns = Split(sColumnsLine, strDelimiter)
    Set pColumns = New Scripting.Dictionary

    If Len(strTextQualifier) > 0 Then
        If strTextQualifier = "quote" Then
            strTextQualifier = """"
        End If
        For nIndex = LBound(arrColumns) To UBound(arrColumns)
            If Left(arrColumns(nIndex), 1) = strTextQualifier Then
                arrColumns(nIndex) = Mid(arrColumns(nIndex), 2)
            End If

            If Right(arrColumns(nIndex), 1) = strTextQualifier Then
                arrColumns(nIndex) = Left(arrColumns(nIndex), Len(arrColumns(nIndex)) - 1)
            End If
        Next
    End If

    For nIndex = LBound(arrColumns) To UBound(arrColumns)
        If pColumns.Exists(arrColumns(nIndex)) = True Then
            Call UI.ShowError(Application.GetText("textfileimport", "columnNameDoubles", "xmlImport"))
        Else
            Call pColumns.Add(arrColumns(nIndex), "")
        End If
    Next nIndex

    If pColumns.count = 0 Then
        Call UI.ShowError(Application.GetText("textfileimport", "noColumnNames", "xmlImport"))
    End If

    Call SortColumns(pColumns)

    Set pColumnsNode = pXml.createElement("columns")

    For nIndex = 0 To pColumns.count - 1
        Call pColumnsNode.SetAttribute("c" & nIndex, pColumns.Keys(nIndex))
    Next nIndex

    Call pXml.selectSingleNode("/settings").appendChild(pColumnsNode)

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AppendFileColumns" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Function AppendTabColumns(ByVal pTab As MSXML2.IXMLDOMElement, ByVal pClass As LDE.Class, Optional pParentField As LDE.field = Nothing) As Boolean
    On Error GoTo ErrorHandler
    Dim pColumn As MSXML2.IXMLDOMElement
    Dim pField As LDE.field
    Dim bSkipField As Boolean
    Dim blnSeparatorAdded As Boolean

    blnSeparatorAdded = False
    For Each pField In pClass.Fields
        bSkipField = pField.BuiltIn

        If Not bSkipField And Not pParentField Is Nothing Then
            bSkipField = (pField.Name = pParentField.LinkedField.Name)
        End If

        If Not bSkipField Then
            Select Case pField.Type
                Case lkFieldTypeAutomatic, lkFieldTypeMultiLink, lkFieldTypeSQL, lkFieldTypeDocument, lkFieldTypeUser:
                    bSkipField = True
                Case lkFieldTypeLink:
                    If pField.LinkedField.Class.Label = lkClassLabelCoWorker Then
                        bSkipField = False
                    ElseIf pField.LinkedField.Class.Name = pTab.GetAttribute("linkedfield") Then
                        bSkipField = True
                    Else
                        bSkipField = False
                    End If

                Case Else
                    bSkipField = False
            End Select
        End If

        If Not bSkipField Then
            Set pColumn = pTab.ownerDocument.createElement("column")
            Call pColumn.SetAttribute("name", pField.Name)
            If pClass.Fields.count > 12 Then
                If pField.Attribute("separator") = "1" Or pField.Attribute("separator") = "2" Then
                    Call pColumn.SetAttribute("separator", pField.Attribute("separatorlocalname"))
                    blnSeparatorAdded = True
                End If
            End If
            Call pTab.appendChild(pColumn)
        End If
    Next pField

    AppendTabColumns = blnSeparatorAdded
    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AppendTabColumns" & vbCrLf & Err.Source, Err.Description)
End Function

Private Sub AppendTabs(ByVal pXml As MSXML2.DOMDocument60)
    On Error GoTo ErrorHandler
    Dim pTabs As MSXML2.IXMLDOMElement
    Dim pTab As MSXML2.IXMLDOMElement
    Dim pClass As LDE.Class
    Dim pField As LDE.field
    Dim blnSeparatorFound As Boolean

    Set pTabs = pXml.createElement("tabs")

    Set pClass = Application.ActiveExplorer.Class
    Set pTab = pXml.createElement("tab")
    Call pTab.SetAttribute("name", pClass.LocalName)
    Call pTab.SetAttribute("class", pClass.Name)
    Call pTab.SetAttribute("field", "")
    Call pTab.SetAttribute("linkedfield", "")

    blnSeparatorFound = AppendTabColumns(pTab, pClass)
    If blnSeparatorFound Then
        Call pTab.SetAttribute("separatoradded", "true")
    Else
        Call pTab.SetAttribute("separatoradded", "false")
    End If

    If pTab.childNodes.Length = 0 Then
        Call UI.ShowError(Application.GetText("textfileimport", "noFields", "xmlImport", pClass.LocalName))
    End If

    Call pTabs.appendChild(pTab)

    For Each pField In pClass.Fields
        If pField.Type = lkFieldTypeMultiLink And pField.Visible = True Then
            Set pTab = pXml.createElement("tab")
            Call pTab.SetAttribute("name", pField.LocalName)
            Call pTab.SetAttribute("class", pField.LinkedField.Class.Name)
            Call pTab.SetAttribute("field", pField.Name)
            Call pTab.SetAttribute("linkedfield", pField.LinkedField.Name)

            blnSeparatorFound = AppendTabColumns(pTab, pField.LinkedField.Class, pField)
            If blnSeparatorFound Then
                Call pTab.SetAttribute("separatoradded", "true")
            Else
                Call pTab.SetAttribute("separatoradded", "false")
            End If

            If pTab.childNodes.Length > 0 Then
                Call pTabs.appendChild(pTab)
            End If
        End If
    Next pField

    Call pXml.selectSingleNode("/settings").appendChild(pTabs)

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AppendTabs" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Sub CreateSchemaIniFile(strFileFormat As String)
    On Error GoTo ErrorHandler
    Dim fso As New Scripting.FileSystemObject
    Dim Stream As Scripting.TextStream
    Dim FileName As String

    FileName = GetSchemaIniFile()

    If fso.FileExists(FileName) Then
        fso.DeleteFile FileName
    End If

    Select Case strFileFormat
        Case "TabDelimited", "CSVDelimited":
           'Do nothing
        Case "":
            strFileFormat = "TabDelimited"
        Case Else:
            strFileFormat = "Delimited(" & strFileFormat & ")"
    End Select

    Set Stream = fso.OpenTextFile(FileName, ForWriting, True)
    Stream.WriteLine "[" & ExtractFileName(m_sImportFile) & "]"
    Stream.WriteLine "ColNameHeader=True"
    Stream.WriteLine "Format=" & strFileFormat
    Stream.WriteLine "Maxscanrows=0"
    Stream.WriteLine "Characterset=ANSI"

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CreateSchemaIniFile" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Function CreateXmlDocument(ByVal sXml As String) As MSXML2.DOMDocument60
    On Error GoTo ErrorHandler
    Dim pXmlDocument As MSXML2.DOMDocument60

    Set pXmlDocument = New MSXML2.DOMDocument60
    pXmlDocument.async = False
    pXmlDocument.validateOnParse = True
    Call pXmlDocument.loadXML(sXml)
    Call pXmlDocument.SetProperty("SelectionLanguage", "XPath")

    Set CreateXmlDocument = pXmlDocument

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CreateXmlDocument" & vbCrLf & Err.Source, Err.Description)
End Function

Private Sub DeleteSchemaIniFile()
    On Error GoTo ErrorHandler
    Dim fso As New Scripting.FileSystemObject
    Dim FileName As String

    FileName = GetSchemaIniFile()

    If fso.FileExists(FileName) Then
        fso.DeleteFile FileName
    End If

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::DeleteScheamaIniFile" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Function GetAlternativesFromFile(ByVal sColumn As String, strFormat As String) As Scripting.Dictionary
    On Error GoTo ErrorHandler
    Dim pConnection As ADODB.Connection
    Dim pRecordset As ADODB.Recordset
    Dim pDictionary As Scripting.Dictionary
    Dim sFileName As String
    Dim sFilePath As String
    Dim sSql As String
    Dim vFileMaxHits As Variant

    If m_lngFileHits = 0 Then
        vFileMaxHits = LCO.GetIniString("textfileimport", "FileAlternatives", "maxhits", 100)
        If IsNumeric(vFileMaxHits) Then
            m_lngFileHits = CLng(vFileMaxHits)
        Else
            m_lngFileHits = 100
        End If
    End If

    Call CreateSchemaIniFile(strFormat)

    sFileName = ExtractFileName(m_sImportFile)
    sFilePath = ExtractFilePath(m_sImportFile)

    sSql = "SELECT DISTINCT [" & sColumn & "], count(*) as [hits] FROM [" & sFileName & "] GROUP BY [" & sColumn & "]"

    Set pConnection = New ADODB.Connection
    Call pConnection.Open("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & sFilePath & ";Extended Properties=""Text;HDR=NO;Fmt=Delimited""")

    Set pRecordset = New ADODB.Recordset
    pRecordset.CursorLocation = adUseClient
    Call pRecordset.Open(sSql, pConnection, adOpenStatic, adLockReadOnly, adCmdText)

    Set pDictionary = New Scripting.Dictionary

    While Not pRecordset.EOF And pDictionary.count < m_lngFileHits
        If IsNull(pRecordset.Fields.Item(sColumn).Value) = False Then
            Call pDictionary.Add(CStr(pRecordset.Fields.Item(sColumn).Value), pRecordset.Fields("hits").Value)
        End If

        Call pRecordset.MoveNext
    Wend

    Call DeleteSchemaIniFile

    Set GetAlternativesFromFile = pDictionary

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetAlternativesFromFile" & vbCrLf & Err.Source, Err.Description)
End Function

Public Function CheckAlternatives(strXML As String, strTableName As String, strFieldName As String, strColumn As String, strFormat As String, ByRef blnChangedXML As Variant) As String
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pAlternativesXML As New MSXML2.DOMDocument60
    Dim strLimeValue As String
    Dim pDictionary  As Scripting.Dictionary
    Dim pOptionNode As MSXML2.IXMLDOMElement
    Dim i As Integer
    Dim pField As LDE.field
    Dim strDefaultOption  As Long
    Dim pOption As LDE.Option
    Dim strValue As String

    blnChangedXML = False
    Call pAlternativesXML.loadXML(strXML)
    Call pAlternativesXML.SetProperty("SelectionLanguage", "XPath")

    If Database.Classes(strTableName).Fields(strFieldName).Type <> lkFieldTypeYesNo Then
        If Len(pAlternativesXML.selectSingleNode("/options").Attributes.getNamedItem("classname").Text) = 0 Then
            'Check if Lime values still are valid

            For Each pNode In pAlternativesXML.selectNodes("//limeoption")
                strLimeValue = pNode.Attributes.getNamedItem("value").Text
                strLimeValue = Replace(strLimeValue, ";", "")
                If strLimeValue < "0" Then
                    If Database.Classes(strTableName).Fields(strFieldName).options.Lookup(strLimeValue, lkLookupOptionByValue) Is Nothing Then
                        Call pAlternativesXML.selectSingleNode("//limeoptions").removeChild(pNode)
                        blnChangedXML = True
                    End If
                End If
            Next


            'Check if mapped fields are mapped to valid values
            For Each pNode In pAlternativesXML.selectNodes("//fileoption")
                strLimeValue = pNode.Attributes.getNamedItem("limevalue").Text
                strLimeValue = Replace(strLimeValue, ";", "")
                If Database.Classes(strTableName).Fields(strFieldName).options.Lookup(strLimeValue, lkLookupOptionByValue) Is Nothing Then
                    Call pAlternativesXML.selectSingleNode("//fileoptions").removeChild(pNode)
                    blnChangedXML = True
                End If
            Next


            'Check if defaultvalue is valid
            Set pNode = pAlternativesXML.selectSingleNode("options/defaultoption")
            strLimeValue = pNode.Attributes.getNamedItem("value").Text
            strLimeValue = Replace(strLimeValue, ";", "")
            If Database.Classes(strTableName).Fields(strFieldName).options.Lookup(strLimeValue, lkLookupOptionByValue) Is Nothing Then
                Set pField = Database.Classes(strTableName).Fields(strFieldName)

                pNode.Attributes.getNamedItem("text").Text = Application.GetText("textfileimport", "selectDefault", "alternativeDialog")
                If pField.Required Then
                    pNode.Attributes.getNamedItem("value").Text = -101
                Else
                    pNode.Attributes.getNamedItem("value").Text = 0
                End If
                blnChangedXML = True

            End If

        Else
            blnChangedXML = CheckLinkedFields(pAlternativesXML, strTableName, strFieldName)
        End If
    End If

    Set pDictionary = GetAlternativesFromFile(strColumn, strFormat)
    'Check if file contains new alternatives
    For i = 0 To pDictionary.count - 1
        If pAlternativesXML.selectNodes("//fileoption[@text='" & pDictionary.Keys(i) & "']").Length = 0 Then
            Set pOptionNode = pAlternativesXML.createElement("fileoption")
            Call pOptionNode.SetAttribute("text", pDictionary.Keys(i))
            Call pOptionNode.SetAttribute("hits", pDictionary.items(i))
            Call pOptionNode.SetAttribute("limetext", "")
            Call pOptionNode.SetAttribute("limevalue", "")
            Call pAlternativesXML.selectSingleNode("//fileoptions").appendChild(pOptionNode)
            blnChangedXML = True
        Else
            Set pOptionNode = pAlternativesXML.selectSingleNode(("//fileoption[@text='" & pDictionary.Keys(i) & "']"))
            Call pOptionNode.SetAttribute("hits", pDictionary.items(i))
        End If
    Next

    CheckAlternatives = pAlternativesXML.xml

    Exit Function
ErrorHandler:
    Call UI.ShowError("XmlImport::CheckAlternatives" & vbCrLf & Err.Source)
End Function

Private Function CheckLinkedFields(pAlternativesXML As MSXML2.DOMDocument60, strTableName As String, strFieldName As String) As Boolean
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pRecords As LDE.Records
    Dim pPool As LDE.Pool
    Dim pFilter As LDE.Filter
    Dim pView As LDE.View
    Dim vID As Variant
    Dim strLinkedClass As String
    Dim i As Long

    If Database.Classes.Exists(strTableName) Then
        If Database.Classes(strTableName).Fields.Exists(strFieldName) Then
            If Not Database.Classes(strTableName).Fields(strFieldName).LinkedField Is Nothing Then
                strLinkedClass = Database.Classes(strTableName).Fields(strFieldName).LinkedField.Class.Name
                If pAlternativesXML.selectNodes("//limeoption").Length > 0 Then
                    Set pPool = New LDE.Pool

                    For Each pNode In pAlternativesXML.selectNodes("//limeoption")
                        vID = pNode.Attributes.getNamedItem("value").Text
                        If IsNumeric(vID) Then
                            Call pPool.Add(CLng(vID))
                        End If
                    Next

                    If pPool.count > 0 Then
                        Set pFilter = New LDE.Filter
                        Set pView = New LDE.View
                        Set pRecords = New LDE.Records

                        Call pFilter.AddCondition("id" & strLinkedClass, lkOpIn, pPool, lkConditionTypePool)
                        Call pView.Add("id" & strLinkedClass)

                        Call pRecords.Open(Classes(strLinkedClass), pFilter, pView)
                        If pRecords.count = pPool.count Then
                            CheckLinkedFields = False
                        Else
                            Call pPool.Remove(pRecords.Pool)

                            For i = 0 To pPool.count - 1
                                For Each pNode In pAlternativesXML.selectNodes("/options/limeoptions/limeoption[@value='" & Trim(pPool(i)) & "']")
                                    Call pNode.parentNode.removeChild(pNode)
                                Next

                                For Each pNode In pAlternativesXML.selectNodes("/options/fileoptions/fileoption[@limevalue='" & Trim(pPool(i)) & "']")
                                    pNode.Attributes.getNamedItem("limevalue").Text = ""
                                    pNode.Attributes.getNamedItem("limetext").Text = ""
                                Next
                            Next

                            CheckLinkedFields = True
                        End If
                    End If
                End If
            Else
                Call DeleteLimeOptionsFromConfigFile(pAlternativesXML)
                CheckLinkedFields = True
            End If
        Else
            Call DeleteLimeOptionsFromConfigFile(pAlternativesXML)
            CheckLinkedFields = True
        End If
    Else
        Call DeleteLimeOptionsFromConfigFile(pAlternativesXML)
        CheckLinkedFields = True
    End If

End Function

Private Sub DeleteLimeOptionsFromConfigFile(pAlternativesXML As MSXML2.DOMDocument60)
    Dim pNode As MSXML2.IXMLDOMNode

    Set pNode = pAlternativesXML.selectSingleNode("/options/limeoptions")
    Call pNode.parentNode.removeChild(pNode)

End Sub

Private Sub SetMaxFilterHits()

    Dim vFilterMaxHits As Variant
    If m_lngFilterHits = 0 Then
        vFilterMaxHits = LCO.GetIniString("textfileimport", "Filter", "maxhits", 100)
        If IsNumeric(vFilterMaxHits) Then
            m_lngFilterHits = CLng(vFilterMaxHits)
        Else
            m_lngFilterHits = 100
        End If
    End If
End Sub

Public Function GetFieldAlternatives(ByVal strTableName As String, ByVal sFieldName As String, ByVal sFileColumn As String, ByVal strFormat As String) As String
    On Error GoTo ErrorHandler

    Dim pOptionsDocument As MSXML2.DOMDocument60
    Dim pOptionNode As MSXML2.IXMLDOMElement
    Dim pOption As LDE.Option
    Dim pField As LDE.field
    Dim pLimeOptionsMap As Scripting.Dictionary
    Dim pFileOptions As Scripting.Dictionary
    Dim sKey As String
    Dim nDefaultOption As Long
    Dim nIndex As Integer
    Dim pView As LDE.View
    Dim pRecords As LDE.Records
    Dim pRecord As LDE.Record
    Dim strLinkedObjectClass As String


    Set pField = Application.Classes.Item(strTableName).Fields.Item(sFieldName)
    Set pLimeOptionsMap = New Scripting.Dictionary
    strLinkedObjectClass = ""

    If Not pField.LinkedField Is Nothing Then
        strLinkedObjectClass = pField.LinkedField.Class.Name
    End If

    Set pOptionsDocument = CreateXmlDocument("<?xml version=""1.0"" encoding=""ISO-8859-1""?><options classname=""" & strLinkedObjectClass & """ required=""" & pField.Required & """><limeoptions/><fileoptions/></options>") '
    Set pOptionNode = pOptionsDocument.createElement("limeoption")
    Call pOptionNode.SetAttribute("text", Application.GetText("textfileimport", "selectDefault", "alternativeDialog"))
    If pField.Required = False Then
        Call pOptionNode.SetAttribute("value", "0")
    Else
        Call pOptionNode.SetAttribute("value", "-101")
    End If
    Call pOptionNode.SetAttribute("default", "1")
    Call pOptionsDocument.selectSingleNode("/options/limeoptions").appendChild(pOptionNode)

    If pField.Type = lkFieldTypeOption Then
        nDefaultOption = CLng(pField.Attribute("defaultvalue"))

        For Each pOption In pField.options
            If pLimeOptionsMap.Exists(LCase(pOption.Text)) = False And (pOption.Value <> nDefaultOption Or pField.Required = False) Then
                Set pOptionNode = pOptionsDocument.createElement("limeoption")
                Call pOptionNode.SetAttribute("text", pOption.Text)
                Call pOptionNode.SetAttribute("value", pOption.Value)
                Call pOptionNode.SetAttribute("default", IIf(pOption.Value = nDefaultOption, "1", "0"))
                Call pOptionsDocument.selectSingleNode("/options/limeoptions").appendChild(pOptionNode)

                Call pLimeOptionsMap.Add(LCase(pOption.Text), pOptionNode)
            End If
        Next pOption

    ElseIf pField.Type = lkFieldTypeSet Then


        For Each pOption In pField.options
            If pLimeOptionsMap.Exists(LCase(pOption.Text)) = False And (pOption.Value <> nDefaultOption Or pField.Required = False) Then
                Set pOptionNode = pOptionsDocument.createElement("limeoption")
                Call pOptionNode.SetAttribute("text", pOption.Text)
                Call pOptionNode.SetAttribute("value", ";" & pOption.Value & ";")
                Call pOptionNode.SetAttribute("default", "0")
                Call pOptionsDocument.selectSingleNode("/options/limeoptions").appendChild(pOptionNode)

                Call pLimeOptionsMap.Add(LCase(pOption.Text), pOptionNode)
            End If
        Next pOption

    ElseIf pField.Type = lkFieldTypeYesNo Then
        Set pOptionNode = pOptionsDocument.createElement("limeoption")
        Call pOptionNode.SetAttribute("text", Application.GetText("textfileimport", "yes", "yesNoAlternatives"))
        Call pOptionNode.SetAttribute("value", "101")
        Call pOptionNode.SetAttribute("default", "100")
        Call pOptionsDocument.selectSingleNode("/options/limeoptions").appendChild(pOptionNode)
        'Call pLimeOptionsMap.Add("yes", pOptionNode)

        Set pOptionNode = pOptionsDocument.createElement("limeoption")
        Call pOptionNode.SetAttribute("text", Application.GetText("textfileimport", "no", "yesNoAlternatives"))
        Call pOptionNode.SetAttribute("value", "100")
        Call pOptionNode.SetAttribute("default", "100")
        Call pOptionsDocument.selectSingleNode("/options/limeoptions").appendChild(pOptionNode)

    ElseIf pField.Type = lkFieldTypeLink Then
        Call pOptionsDocument.selectSingleNode("/options/limeoptions").appendChild(GetExplorerFilters(pField.LinkedField.Class.Name, pOptionsDocument))
    End If

    Set pFileOptions = GetAlternativesFromFile(sFileColumn, strFormat)

    If Not pFileOptions Is Nothing Then
        For nIndex = 0 To pFileOptions.count - 1
            If Len(pFileOptions.Keys(nIndex)) > 0 Then
                Set pOptionNode = pOptionsDocument.createElement("fileoption")
                Call pOptionNode.SetAttribute("text", pFileOptions.Keys(nIndex))
                Call pOptionNode.SetAttribute("hits", pFileOptions.items(nIndex))

                sKey = LCase(Trim(pFileOptions.Keys(nIndex)))

                If pField.Type = lkFieldTypeYesNo Then
                    Select Case sKey
                        Case "0", "false", "falskt", "no", "nej", ""
                            Call pOptionNode.SetAttribute("limetext", Application.GetText("textfileimport", "no", "yesNoAlternatives"))
                            Call pOptionNode.SetAttribute("limevalue", "100")
                        Case "1", "true", "sant", "yes", "ja"
                            Call pOptionNode.SetAttribute("limetext", Application.GetText("textfileimport", "yes", "yesNoAlternatives"))
                            Call pOptionNode.SetAttribute("limevalue", "101")
                        Case Else:
                            Call pOptionNode.SetAttribute("limetext", "")
                            Call pOptionNode.SetAttribute("limevalue", "")
                        End Select
                Else
                    If pLimeOptionsMap.Exists(sKey) = True Then
                        Call pOptionNode.SetAttribute("limetext", pLimeOptionsMap.Item(sKey).Attributes.getNamedItem("text").nodeValue)
                        Call pOptionNode.SetAttribute("limevalue", pLimeOptionsMap.Item(sKey).Attributes.getNamedItem("value").nodeValue)
                    Else
                        Call pOptionNode.SetAttribute("limetext", "")
                        Call pOptionNode.SetAttribute("limevalue", "")
                    End If
                End If

                Call pOptionsDocument.selectSingleNode("/options/fileoptions").appendChild(pOptionNode)
            End If
        Next nIndex
    End If

    GetFieldAlternatives = pOptionsDocument.xml

    Exit Function
ErrorHandler:
    Call UI.ShowError("XmlImport.GetFieldAlternatives")
End Function

Private Function GetExplorerFilters(strExplorerName As String, pOptionsDocument As MSXML2.DOMDocument60) As MSXML2.IXMLDOMElement
    Dim pFilter As LDE.Filter
    Dim pOptionElement As MSXML2.IXMLDOMElement
    Dim pRoot As MSXML2.IXMLDOMElement

    Call SetMaxFilterHits

    Set pRoot = pOptionsDocument.createElement("filters")
    Call pRoot.SetAttribute("maxhits", m_lngFilterHits)
    Call pRoot.SetAttribute("hits", 0)

    For Each pFilter In Application.Explorers(strExplorerName).Filters
        Set pOptionElement = pOptionsDocument.createElement("filter")
        Call pOptionElement.SetAttribute("name", pFilter.Name)
        Call pOptionElement.SetAttribute("selected", "0")
        Call pRoot.appendChild(pOptionElement)
    Next

    Set pOptionElement = pOptionsDocument.createElement("filter")
    Call pOptionElement.SetAttribute("name", Application.GetText("textfileimport", "searchResults", "alternativeDialog"))
    Call pOptionElement.SetAttribute("selected", "0")
    Call pOptionElement.SetAttribute("searchresult", "lime")    'Dummy value when loaded
    Call pRoot.appendChild(pOptionElement)

    Set GetExplorerFilters = pRoot

End Function

Public Sub SetMousePointer(Optional intValue As Integer = 0)
    Application.MousePointer = intValue
End Sub

Public Function GetCoworkers(strCoworkerClass As String) As String
    Dim pXMLDoc As MSXML2.DOMDocument60
    Dim pFilterRoot As MSXML2.IXMLDOMNode
    Dim pNode As MSXML2.IXMLDOMNode

    Set pXMLDoc = New MSXML2.DOMDocument60

    Set pNode = pXMLDoc.createElement("options")
    Call pNode.Attributes.setNamedItem(GetAttribute(strCoworkerClass, "classname", pXMLDoc))
    Call pXMLDoc.appendChild(pNode)

    Set pNode = pXMLDoc.createElement("limeoptions")
    Call pXMLDoc.selectSingleNode("/options").appendChild(pNode)


    Set pFilterRoot = GetExplorerFilters(strCoworkerClass, pXMLDoc)
    Call pXMLDoc.selectSingleNode("/options/limeoptions").appendChild(pFilterRoot)
    GetCoworkers = GetLinkedObjects(strCoworkerClass, pXMLDoc, "")
End Function

Public Function GetLinkedObjects(strClassName As String, pXMLDoc As MSXML2.DOMDocument60, strFilterName As String) As String
    Dim pOptionElement As MSXML2.IXMLDOMElement
    Dim pView As LDE.View
    Dim pRecords As LDE.Records
    Dim pRecord As LDE.Record
    Dim pOptionXML As MSXML2.DOMDocument60
    Dim strCoworkerClass As String
    Dim pLimeOption As MSXML2.IXMLDOMElement
    Dim pFilter As LDE.Filter
    Dim pFileOption As MSXML2.IXMLDOMNode
    Dim pPool As LDE.Pool
    Dim pTempFilter As LDE.Filter
    Dim lngHits As Long
    Dim lngDefaultValue As Long
    Dim pSearchResultElement As MSXML2.IXMLDOMElement
    Dim pFiltersNode As MSXML2.IXMLDOMNode

    Call SetMaxFilterHits

    lngHits = 0
    If Len(strFilterName) > 0 Then
        Set pFilter = New LDE.Filter
        If Application.Explorers.Item(strClassName).Filters.Exists(strFilterName) Then
            Set pFilter = Application.Explorers.Item(strClassName).Filters.Item(strFilterName)
        ElseIf strFilterName = Application.GetText("textfileimport", "searchResults", "alternativeDialog") Then
            Set pFilter = New LDE.Filter

            Set pSearchResultElement = pXMLDoc.selectSingleNode("/options/limeoptions/filters/filter[@searchresult!='']")
            If Not pSearchResultElement Is Nothing Then
                Call pFilter.AddCondition("descriptive", lkOpLike, pSearchResultElement.GetAttribute("searchresult"))
            End If
        Else
            Set pFilter = Nothing
        End If
    Else
        Set pFilter = Nothing
    End If

    If Not pFilter Is Nothing Then
        Set pTempFilter = pFilter.Clone
    End If
    Set pView = New LDE.View
    Set pRecords = New LDE.Records

    Call pView.Add("descriptive", lkSortAscending)
    Call pView.Add("id" & strClassName)

    If Not pFilter Is Nothing Then
        Set pPool = New LDE.Pool
        If pFilter.count = 0 Then
            Call pRecords.Open(Application.Database.Classes(strClassName), pFilter, pView, m_lngFilterHits + 1)
            Call pPool.Add(pRecords.Pool)
        End If

        If pXMLDoc.selectNodes("options/fileoptions/fileoption[@limevalue!='']").Length > 0 Then


            For Each pFileOption In pXMLDoc.selectNodes("options/fileoptions/fileoption[@limevalue!='']")
                Call pPool.Add(CLng(pFileOption.Attributes.getNamedItem("limevalue").Text))
            Next

            If Not pXMLDoc.selectSingleNode("options/defaultoption") Is Nothing Then
                lngDefaultValue = pXMLDoc.selectSingleNode("options/defaultoption").Attributes.getNamedItem("value").Text
                If lngDefaultValue > 0 Then
                    Call pPool.Add(lngDefaultValue)
                End If
            End If

            Call pTempFilter.AddCondition("id" & strClassName, lkOpIn, pPool, lkConditionTypePool)

            If pTempFilter.count > 1 Then
                Call pTempFilter.AddOperator(lkOpOr)
            End If

            lngHits = pPool.count
        End If
    End If

    For Each pLimeOption In pXMLDoc.selectNodes("options/limeoptions/limeoption")
        Call pLimeOption.parentNode.removeChild(pLimeOption)
    Next


    Call pRecords.Open(Application.Database.Classes(strClassName), pTempFilter, pView, m_lngFilterHits + lngHits + 1)

    For Each pRecord In pRecords
        Set pOptionElement = pXMLDoc.createElement("limeoption")
        Call pOptionElement.SetAttribute("text", pRecord.Value("descriptive"))
        Call pOptionElement.SetAttribute("value", pRecord.Value("id" & strClassName))
        'Used for randomized coworkers
        Call pOptionElement.SetAttribute("selected", "0")

        If InStr(1, pRecord.Value("descriptive"), "'") Then
            Set pFileOption = pXMLDoc.selectSingleNode("/options/fileoptions/fileoption[@limevalue="""" and @text=""" & pRecord.Value("descriptive") & """]")
        Else
            Set pFileOption = pXMLDoc.selectSingleNode("/options/fileoptions/fileoption[@limevalue='' and @text='" & pRecord.Value("descriptive") & "']")
        End If
        If Not pFileOption Is Nothing Then
            pFileOption.Attributes.getNamedItem("limetext").Text = pRecord.Value("descriptive")
            pFileOption.Attributes.getNamedItem("limevalue").Text = pRecord.Value("id" & strClassName)
        End If

        Call pXMLDoc.selectSingleNode("/options/limeoptions").appendChild(pOptionElement)
    Next

    Set pFiltersNode = pXMLDoc.selectSingleNode("/options/limeoptions/filters")
    If Not pFiltersNode.Attributes.getNamedItem("hits") Is Nothing Then
        pFiltersNode.Attributes.getNamedItem("hits").Text = pRecords.count
    End If

    GetLinkedObjects = pXMLDoc.xml
End Function

Private Sub MLYTest(pFilter As LDE.Filter, strClassName As String)
    Dim P As New Lime.Dialog

    Set P = New Lime.Dialog
    P.Property("Class") = Database.Classes(strClassName)
    P.Property("Filter") = pFilter

    If P.show(lkDialogFilter) = vbOK Then
        MsgBox "HUBBA BUBBA"
    End If

End Sub

Private Function GetCoworkerClass() As String
    Dim pClass As LDE.Class
    Dim strClassName As String

    For Each pClass In Application.Database.Classes
        If pClass.Label = lkClassLabelCoWorker Then
            strClassName = pClass.Name
            Exit For
        End If
    Next

    GetCoworkerClass = strClassName

End Function

Private Function GetOptionValue(ByVal pColumn As MSXML2.IXMLDOMElement, ByVal Value As Variant) As Variant
    On Error GoTo ErrorHandler
    Dim OptionsNode As MSXML2.IXMLDOMElement, OptionNode As MSXML2.IXMLDOMElement
    Dim strSearchString As String

    GetOptionValue = Null

    Set OptionsNode = pColumn.ownerDocument.selectSingleNode(Application.FormatString("/import/options[@columnalias='%1']", pColumn.GetAttribute("alias")))

    If Not OptionsNode Is Nothing Then
        If OptionsNode.GetAttribute("randomize") = "1" Then
            If OptionsNode.childNodes.Length > 0 Then
                If m_lngCoworkerRandomizedNumber < 0 Then
                    m_lngCoworkerRandomizedNumber = Globals.GetRandomNumber(0, OptionsNode.childNodes.Length)
                Else
                    m_lngCoworkerRandomizedNumber = m_lngCoworkerRandomizedNumber + 1
                    If m_lngCoworkerRandomizedNumber > OptionsNode.childNodes.Length - 1 Then
                        m_lngCoworkerRandomizedNumber = 0
                    End If
                End If

                Set OptionNode = OptionsNode.childNodes.Item(m_lngCoworkerRandomizedNumber)
            End If
        ElseIf Not IsNull(Value) Then
            strSearchString = Application.FormatString("option[@file=""%1""]", CStr(Value))
            Set OptionNode = OptionsNode.selectSingleNode(strSearchString)
        End If

        If Not OptionNode Is Nothing Then
            GetOptionValue = OptionNode.GetAttribute("lime")
        End If

        If IsNull(GetOptionValue) Then
            GetOptionValue = ""
        End If
    End If

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetOptionValue" & vbCrLf & Err.Source, Err.Description)
End Function

Private Function GetRelationFieldValue(ByVal pColumn As MSXML2.IXMLDOMNode, ByVal vtValue As Variant) As Variant
    On Error GoTo ErrorHandler
    Dim pClass As LDE.Class
    Dim vtResult As Variant
    Dim sClass As String
    Dim sField As String

    sClass = pColumn.parentNode.Attributes.getNamedItem("class").nodeValue
    sField = pColumn.Attributes.getNamedItem("lime").nodeValue

    Set pClass = Application.Classes.Item(sClass)

    ' At this point we only support coworker fields
    Select Case pClass.Fields.Item(sField).LinkedField.Class.Label
        Case lkClassLabelCoWorker:
            vtResult = GetOptionValue(pColumn, vtValue)

            If IsNull(vtResult) = True Then
                vtResult = LookupCoworker(vtValue)
            End If
        Case Else:
            vtResult = GetOptionValue(pColumn, vtValue)
    End Select

    GetRelationFieldValue = vtResult

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetRelationFieldValue" & vbCrLf & Err.Source, Err.Description)
End Function

Private Function GetSchemaIniFile() As String
    On Error Resume Next
    GetSchemaIniFile = MakeFileName(ExtractFilePath(m_sImportFile), "schema.ini")
End Function

Public Function GetSettings() As Variant
    On Error Resume Next
    Set GetSettings = m_pSettings
End Function



Public Function InitializeImport(ByVal strFileFormat As String, ByVal strTextQualifier As String) As Boolean
    On Error GoTo ErrorHandler

    Dim Dialog As New LCO.FileOpenDialog

    m_sImportFile = ""
    'm_HTML = ""

    Set m_pSettings = CreateXmlDocument("<?xml version=""1.0"" encoding=""ISO-8859-1""?><settings/>")
    Set m_pCoworkers = Nothing

    If Application.ActiveExplorer Is Nothing Then
        Call UI.ShowError(Application.GetText("textfileimport", "selectTab", "xmlImport"))
    End If

    Dialog.Filter = "Text File (.txt)|*.txt"

    If Dialog.show = vbOK Then
        m_sImportFile = Dialog.FileName

        If IsFileOpen(m_sImportFile) Then
            Call Lime.MessageBox("Filen går inte att öppna, kontrollera att den inte är redan är öppen någon annanstans!", vbExclamation + vbOKOnly)
            Exit Function
        End If

        Call AppendFileColumns(m_pSettings, strFileFormat, strTextQualifier)
        Call AppendTabs(m_pSettings)

        InitializeImport = True
    End If

    Exit Function
ErrorHandler:
    Call UI.ShowError("XmlImport.InitializeImport")
End Function
Private Function IsFileOpen(FileName As String)
    Dim iFilenum As Long
    Dim iErr As Long
    On Error Resume Next

    iFilenum = FreeFile()
    Open FileName For Input Lock Read As #iFilenum
    Close iFilenum
    iErr = Err
    On Error GoTo 0

    Select Case iErr
        Case 0: IsFileOpen = False
        Case 70: IsFileOpen = True
        Case Else: Error iErr
    End Select

End Function
Public Function LoadConfiguration() As String
    On Error GoTo ErrorHandler
    Dim pDialog As LCO.FileOpenDialog
    Dim pFso As Scripting.FileSystemObject
    Dim pStream As Scripting.TextStream
    Dim sFileName As String
    Dim sXmlData As String
    Dim pLoadXML As MSXML2.DOMDocument60

    Set pDialog = New LCO.FileOpenDialog
    pDialog.Filter = "XML-dokument (.xml)|*.xml"
    sXmlData = ""

    If pDialog.show = vbOK Then
        sFileName = pDialog.FileName
        Set pLoadXML = New MSXML2.DOMDocument60

        If pLoadXML.Load(sFileName) Then
            Call CheckAndFixFieldsInConfigFile(pLoadXML)
            sXmlData = pLoadXML.xml
        Else
            Call UI.ShowError("Konfigurationsfilen kunde inte laddas.")
        End If

    End If

    LoadConfiguration = sXmlData

    Exit Function
ErrorHandler:
    Call UI.ShowError("XmlImport.LoadConfiguration")
End Function

Private Sub CheckAndFixFieldsInConfigFile(ByRef pLoadXML As MSXML2.DOMDocument60)
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim pOptions As New Scripting.Dictionary
    Dim strError As String

    For Each pAttribute In m_pSettings.selectSingleNode("settings/columns").Attributes
        If Not pOptions.Exists(pAttribute.Text) Then
            Call pOptions.Add(CStr(pAttribute.Text), CStr(pAttribute.Text))
        End If
    Next

    For Each pNode In pLoadXML.selectNodes("//box/filefield")
        If Not pNode.Attributes.getNamedItem("name") Is Nothing Then
            If Not pOptions.Exists(pNode.Attributes.getNamedItem("name").Text) Then
                Call pNode.parentNode.parentNode.removeChild(pNode.parentNode)
                strError = strError & "- " & pNode.Attributes.getNamedItem("name").Text & vbCrLf
            End If
        End If
    Next

    If VBA.Len(strError) > 0 Then
        Call Lime.MessageBox("Mallen innehåller fält som inte finns i importfilen, följande saknas;" & vbCrLf & strError, vbExclamation + vbOKOnly)
    End If

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CheckAndFixFieldsInConfigFile" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Function LookupCoworker(ByVal vtValue As Variant) As Variant
    On Error Resume Next

    Dim pClass As LDE.Class
    Dim pRecord As LDE.Record
    Dim vtResult As Variant
    Dim sQuery As String

    vtResult = Null

    If IsNull(vtValue) = False Then
        If m_pCoworkers Is Nothing Then
            Set pClass = Application.Classes.Lookup(lkClassLabelCoWorker, lkLookupClassByLabel)

            If Not pClass Is Nothing Then
                Set m_pCoworkers = Application.CreateObject("LDE.Records")
                Call m_pCoworkers.Open(pClass, , "descriptive")
            End If
        End If

        If Not m_pCoworkers Is Nothing Then
            sQuery = CStr(vtValue)
            sQuery = Replace(sQuery, """", "'")
            sQuery = Application.FormatString("[descriptive] = ""%1""", sQuery)
            Set pRecord = m_pCoworkers.Find(sQuery)

            If Not pRecord Is Nothing Then
                vtResult = pRecord.id
            End If
        End If
    End If

    LookupCoworker = vtResult
End Function

' Open a connection to the import file, compile a query and return the resulting records
Private Function OpenRecordsetFromFile(ByVal pXmlDocument As MSXML2.DOMDocument60, ByVal FileName As String, strFormat As String) As ADODB.Recordset
    On Error GoTo ErrorHandler
    Dim Columns As MSXML2.IXMLDOMNodeList
    Dim Table As MSXML2.IXMLDOMElement, Node As MSXML2.IXMLDOMElement
    Dim Connection As New ADODB.Connection, Recordset As New ADODB.Recordset
    Dim Query As String

    Call CreateSchemaIniFile(strFormat)

    Connection.Open Application.FormatString("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%1;Extended Properties=""Text;HDR=NO;Fmt=Delimited""", ExtractFilePath(FileName))

    Set Table = pXmlDocument.selectSingleNode("/import/table")
    Set Columns = pXmlDocument.selectNodes("//column[@alias!='']")

    For Each Node In Columns
        If Len(Node.Attributes.getNamedItem("alias").nodeValue) > 0 Then
            If Len(Node.GetAttribute("sql")) > 0 Then
                Query = Query & IIf(Len(Query), ", ", "") & Node.GetAttribute("sql") & " AS " & Node.GetAttribute("alias")
            End If
        End If
    Next Node

    '2007-03-21 - added DISTINCT
    '2007-06-25 - deleted DISTINCT again
    Query = Application.FormatString("SELECT %1 FROM [%2]", Query, ExtractFileName(FileName))

    Recordset.CursorLocation = adUseClient
    Call Recordset.Open(Query, Connection, adOpenStatic, adLockReadOnly, adCmdText)

    DeleteSchemaIniFile

    Set OpenRecordsetFromFile = Recordset

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::OpenRecordsetFromFile" & vbCrLf & Err.Source, Err.Description)
End Function

 Private Sub ShowWorking(ByRef intCount As Integer, intStep As Integer)
    Dim strWorkingInformation As String

    If intCount = intStep Then
        strWorkingInformation = m_WorkDialog.Text

        If Right(strWorkingInformation, 3) = "..." Then
            strWorkingInformation = Mid(strWorkingInformation, 1, Len(strWorkingInformation) - 3) & "."
        ElseIf Right(strWorkingInformation, 2) = ".." Then
            strWorkingInformation = Mid(strWorkingInformation, 1, Len(strWorkingInformation) - 2) & "..."
        ElseIf Right(strWorkingInformation, 1) = "." Then
            strWorkingInformation = Mid(strWorkingInformation, 1, Len(strWorkingInformation) - 1) & ".."
        Else
            strWorkingInformation = strWorkingInformation & "."
        End If

        m_WorkDialog.Text = strWorkingInformation

        DoEvents
        intCount = 0
    Else
        intCount = intCount + 1
    End If
 End Sub

'-----------------------------------------------
' ##SUMMARY
'-----------------------------------------------
Private Function GetXMLWithExistingLimeID(ByRef pImportXML As MSXML2.IXMLDOMNode, pView As LDE.View, strTableName As String, strTopNode As String, pTable As MSXML2.IXMLDOMNode) As MSXML2.DOMDocument60
    On Error GoTo ErrorHandler
    Dim i As Integer
    Dim j As Integer
    Dim pChildNode As MSXML2.IXMLDOMNode
    Dim pFilter As LDE.Filter
    Dim pRecords As LDE.Records
    Dim strFieldName As String
    Dim blnIsFirst As Boolean
    Dim pLimeIDXML As MSXML2.DOMDocument60
    Dim strFirstChildNode As String
    Dim lngLength As Long
    Dim pSendToDBView As LDE.View
    Dim pPool As LDE.Pool
    Dim intShowWorking As Integer

    If strTopNode = "sub" Then
        strFirstChildNode = "//" & strTopNode & "/" & strTableName & "[@limeimport__existing = 'True']"
    Else
        strFirstChildNode = "//" & strTopNode & "/" & strTableName
    End If

    If Not pView Is Nothing Then
        Set pSendToDBView = pView.Clone
        Set pPool = New LDE.Pool
        For Each pChildNode In pTable.selectNodes("//column[@type='18']/@lime")
            Call pSendToDBView.Add(pChildNode.nodeValue)
        Next

        If pImportXML.selectNodes(strFirstChildNode).Length > 0 Then

            lngLength = pImportXML.selectNodes("//" & strTopNode & "/" & strTableName).Length
            Set pFilter = New LDE.Filter
            For Each pChildNode In pImportXML.selectNodes(strFirstChildNode)
                If m_WorkDialog.cancel Then
                    Exit For
                End If
                Call ShowWorking(intShowWorking, 50)
                blnIsFirst = True

                For j = 1 To pView.count
                    strFieldName = pView.Item(j).FieldName
                    If InStr(1, strFieldName, ".") > 0 Then
                        strFieldName = Left(strFieldName, InStr(1, strFieldName, ".") - 1)
                    End If
                    If Not pChildNode.Attributes.getNamedItem(strFieldName) Is Nothing Then
                        Call AddConditionToFilter(pFilter, strTableName, strFieldName, pChildNode.Attributes.getNamedItem(strFieldName).Text)
                    Else
                        Call AddConditionToFilter(pFilter, strTableName, strFieldName, "")
                    End If

                    If Not blnIsFirst Then
                       Call pFilter.AddOperator(lkOpAnd)
                    End If
                    blnIsFirst = False
                Next

                If i = INTEXECUTESTEP Or pChildNode Is pImportXML.selectNodes("//" & strTopNode & "/" & strTableName).Item(lngLength - 1) Then
                    If i > 0 Then
                        Call pFilter.AddOperator(lkOpOr)
                    End If
                    Set pRecords = New LDE.Records

                    Call pRecords.Open(Database.Classes(strTableName), pFilter, pSendToDBView)

                    If pRecords.count > 0 Then
                        Call GetXMLFromRecords(pRecords, pLimeIDXML, pPool)
                        Call pPool.Add(pRecords.Pool)

                    End If
                    'Reset
                    Set pFilter = New LDE.Filter
                    i = 0
                Else
                    If i > 0 Then
                        Call pFilter.AddOperator(lkOpOr)
                    End If
                    i = i + 1
                End If
            Next
        End If

        If strTopNode = "sub" Then
            Call DeleteExistingAttribute(pImportXML.selectNodes(strFirstChildNode))
        End If
    End If

    Set GetXMLWithExistingLimeID = pLimeIDXML

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetXMLWithExistingLimeID" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Delete the atteibute limeimport__existing from all subnodes where it exists
'-----------------------------------------------
Private Function DeleteExistingAttribute(pXMLNodes As MSXML2.IXMLDOMNodeList)
    On Error GoTo ErrorHandler
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim pNode As MSXML2.IXMLDOMNode

    For Each pNode In pXMLNodes
        Call pNode.Attributes.removeNamedItem("limeimport__existing")
    Next

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::DeleteExistingAttribute" & vbCrLf & Err.Source, Err.Description)
End Function

Private Function AddConditionToFilter(pFilter As LDE.Filter, strTableName As String, strFieldName As String, strValue As String)
    On Error GoTo ErrorHandler
    Select Case Database.Classes(strTableName).Fields(strFieldName).Type
        Case lkFieldTypeCurrency, lkFieldTypeDecimal, lkFieldTypeGrade, lkFieldTypePercent:
            Call pFilter.AddCondition(strFieldName, lkOpEqual, CDec(strValue))
        Case lkFieldTypeInteger, lkFieldTypeLink, lkFieldTypeOption, lkFieldTypeYesNo:
            Call pFilter.AddCondition(strFieldName, lkOpEqual, CLng(strValue))
        Case Else
            Call pFilter.AddCondition(strFieldName, lkOpEqual, strValue)
    End Select

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AddConditionToFilter" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Loops through attributes in XML and Trim and LCase the values
'-----------------------------------------------
Private Sub TrimAndLCaseAttributeValues(pLimeIDXML As MSXML2.IXMLDOMNode)
    On Error GoTo ErrorHandler
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim pNewAttribute As MSXML2.IXMLDOMAttribute
    Dim strAttributeName As String

    For Each pAttribute In pLimeIDXML.Attributes
        strAttributeName = pAttribute.Name
        pAttribute.Text = Trim(LCase(pAttribute.Text))
        If InStr(1, strAttributeName, ".") > 0 Then
            strAttributeName = Left(strAttributeName, InStr(1, strAttributeName, ".") - 1)
            Set pNewAttribute = pLimeIDXML.ownerDocument.createAttribute(strAttributeName)
            pNewAttribute.Text = pAttribute.Text
            Call pLimeIDXML.Attributes.removeNamedItem(pAttribute.Name)
            Call pLimeIDXML.Attributes.setNamedItem(pNewAttribute)
        End If
    Next


    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::TrimAndLCaseAttributeValues" & vbCrLf & Err.Source, Err.Description)
End Sub

'-----------------------------------------------
' ##SUMMARY Sends importdata to server
' ##PARAM pImportXML XML containing data to be imported
' ##PARAM pExecuteRootNode XML root
'-----------------------------------------------
Private Function ExecuteXMLIntoLime(pImportXML As MSXML2.IXMLDOMNode, pImportLogXML As MSXML2.DOMDocument60, strTopNode As String, strTableName As String, strMainTableName As String, strLinkedFieldInMain As String, strTableNameToShowUser As String) As MSXML2.DOMDocument60
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pChildNode As MSXML2.IXMLDOMNode
    Dim pExecuteXML As MSXML2.DOMDocument60
    Dim pExecuteRootNode As MSXML2.IXMLDOMNode
    Dim pLimeNode As MSXML2.IXMLDOMNode
    Dim i As Integer
    Dim pLimeXML As MSXML2.DOMDocument60
    Dim pExecutedNode As MSXML2.IXMLDOMNode
    Dim lngNumberOfInserted As Long
    Dim lngNumberOfUpdated As Long
    Dim lngLength As Long
    Dim lngRecordsToImport As Long
    Dim j As Long


    i = 1
    lngRecordsToImport = pImportXML.selectNodes("//" & strTopNode & "/" & strTableName).Length
    If lngRecordsToImport > 0 Then
        Set pExecuteXML = New MSXML2.DOMDocument60
        Set pLimeXML = New MSXML2.DOMDocument60
        Call ResetXMLAndAddFirstChild(pExecuteXML, pExecuteRootNode)
        lngLength = pImportXML.selectNodes("//" & strTopNode & "/" & strTableName).Length
        For Each pChildNode In pImportXML.selectNodes(strTableName)
            Call pExecuteRootNode.appendChild(pChildNode.cloneNode(True))
            If i = INTEXECUTESTEP Or pChildNode Is pImportXML.selectNodes("//" & strTopNode & "/" & strTableName).Item(lngLength - 1) Then

                j = j + pExecuteRootNode.childNodes.Length
                Call SetWorkDialogText("importNbrOfRecords", strTableNameToShowUser, CStr(j), CStr(lngRecordsToImport))
                Set pLimeNode = Application.Database.Execute(pExecuteXML)
                If Not pLimeNode Is Nothing Then
                    If Not pImportLogXML Is Nothing Then
                        Call ReplaceTempIDsInLogXML(pImportLogXML, pLimeNode, strTableName, strTopNode)
                    End If
                    If pLimeXML.childNodes.Length = 0 Then
                        Call pLimeXML.appendChild(pLimeNode)
                    Else
                        For Each pExecutedNode In pLimeNode.selectNodes("/xml")
                            Call pLimeXML.selectSingleNode("/xml").appendChild(pExecutedNode)
                        Next
                    End If
                End If
                Call SetWorkDialogProgressBar(m_dblRaiseProgressImportSteps * i)
                '--- Reset
                i = 0
                If Not pChildNode Is pImportXML.selectSingleNode("//" & strTopNode).lastChild Then
                    Call ResetXMLAndAddFirstChild(pExecuteXML, pExecuteRootNode)
                End If
            End If
            i = i + 1
        Next

        lngNumberOfInserted = pImportXML.selectNodes("//" & strTopNode & "/" & strTableName & "[@id" & strTableName & " < '0']").Length
        lngNumberOfUpdated = pImportXML.selectNodes("//" & strTopNode & "/" & strTableName).Length - lngNumberOfInserted
        Call AddImportInformation(pImportLogXML, lngNumberOfInserted, lngNumberOfUpdated, strTableName, strTopNode, strLinkedFieldInMain, strMainTableName)
    End If

    Set ExecuteXMLIntoLime = pLimeXML

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::ExecuteXMLIntoLime" & vbCrLf & Err.Source, Err.Description)
    ExecuteXMLIntoLime = False
End Function

Private Sub ReplaceTempIDsInLogXML(pImportLogXML As MSXML2.DOMDocument60, pLimeNode As MSXML2.IXMLDOMNode, strTableName As String, strTopNode As String)
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pInfoNode As MSXML2.IXMLDOMNode
    Dim lngOldId As Long
    Dim lngNewId As Long

    For Each pNode In pLimeNode.selectNodes("//record")
        If Not pNode.Attributes.getNamedItem("idold") Is Nothing And Not pNode.Attributes.getNamedItem("idnew") Is Nothing Then
            lngOldId = pNode.Attributes.getNamedItem("idold").Text
            lngNewId = pNode.Attributes.getNamedItem("idnew").Text
            For Each pInfoNode In pImportLogXML.selectNodes("//error[@class='" & strTableName & "' and @level='" & strTopNode & "' and @classid='" & lngOldId & "']")
                pInfoNode.Attributes.getNamedItem("classid").Text = lngNewId
            Next
        End If
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::ReplaceTempIDsInLogXML" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Sub AddDeletedInformation(pImportLogXML As MSXML2.DOMDocument60, strTableName As String, strTopNode As String, strLinkedFieldInMain As String)
    On Error GoTo ErrorHandler
    Dim pRoot As MSXML2.IXMLDOMNode
    Dim pImportNode As MSXML2.IXMLDOMNode
    Dim lngNumberOfDeleted As Long

    lngNumberOfDeleted = 1
    Set pRoot = GetImportRoot(pImportLogXML)

    Set pImportNode = pImportLogXML.selectSingleNode("//import[@table='" & strTableName & "." & strLinkedFieldInMain & "' and @level='" & strTopNode & "']/@deleted")

    If pImportNode Is Nothing Then
        Set pImportNode = pImportLogXML.createElement("import")
        Call pRoot.appendChild(pImportNode)
    End If


    If pImportNode.nodeName = "deleted" Then
        lngNumberOfDeleted = CLng(pImportNode.nodeValue) + 1
        pImportNode.Text = lngNumberOfDeleted
    Else
        Call pImportNode.Attributes.setNamedItem(GetAttribute(CStr(lngNumberOfDeleted), "deleted", pImportLogXML))
        Call pImportNode.Attributes.setNamedItem(GetAttribute(strTableName & "." & strLinkedFieldInMain, "table", pImportLogXML))
        Call pImportNode.Attributes.setNamedItem(GetAttribute(strTopNode, "level", pImportLogXML))
        Call pImportNode.Attributes.setNamedItem(GetAttribute(Database.Classes(strTableName).LocalName, "localname", pImportLogXML))
    End If

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AddDeletedInformation" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Sub AddImportInformation(pImportLogXML As MSXML2.DOMDocument60, lngNumberOfInserted As Long, lngNumberOfUpdated As Long, strTableName As String, strTopNode As String, strLinkedFieldInMain As String, strMainTableName As String)
    On Error GoTo ErrorHandler
    Dim pRoot As MSXML2.IXMLDOMNode
    Dim pImportNode As MSXML2.IXMLDOMNode

    Set pRoot = GetImportRoot(pImportLogXML)

    Set pImportNode = pImportLogXML.selectSingleNode("//import[@table='" & strTableName & "." & strLinkedFieldInMain & "' and @level='" & strTopNode & "']")

    If pImportNode Is Nothing Then
        Set pImportNode = pImportLogXML.createElement("import")
        Call pRoot.appendChild(pImportNode)
    End If

    Call pImportNode.Attributes.setNamedItem(GetAttribute(strTableName & "." & strLinkedFieldInMain, "table", pImportLogXML))
    Call pImportNode.Attributes.setNamedItem(GetAttribute(strTopNode, "level", pImportLogXML))
    Call pImportNode.Attributes.setNamedItem(GetAttribute(CStr(lngNumberOfInserted), "inserted", pImportLogXML))
    Call pImportNode.Attributes.setNamedItem(GetAttribute(CStr(lngNumberOfUpdated), "updated", pImportLogXML))
    If Len(strLinkedFieldInMain) > 0 Then
        Call pImportNode.Attributes.setNamedItem(GetAttribute(Database.Classes(strMainTableName).Fields(strLinkedFieldInMain).LocalName, "localname", pImportLogXML))
    Else
        Call pImportNode.Attributes.setNamedItem(GetAttribute(Database.Classes(strMainTableName).LocalName, "localname", pImportLogXML))
    End If

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AddImportInformation" & vbCrLf & Err.Source, Err.Description)
End Sub
'-----------------------------------------------
' ##SUMMARY Delete all nodes from XML and add new root
' ##PARAM pExecuteXML DOMDocument
' ##PARAM pExecuteRootNode XML root
'-----------------------------------------------
Private Sub ResetXMLAndAddFirstChild(ByRef pExecuteXML As MSXML2.DOMDocument60, ByRef pExecuteRootNode As MSXML2.IXMLDOMNode)
    On Error GoTo ErrorHandler

    If Not pExecuteXML.firstChild Is Nothing Then
        Call pExecuteXML.removeChild(pExecuteRootNode)
    End If

    Set pExecuteRootNode = pExecuteXML.createElement("records")
    Call pExecuteXML.appendChild(pExecuteRootNode)

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::ResetXMLAndAddFirstChild" & vbCrLf & Err.Source, Err.Description)
End Sub

'----------------------------------
'##SUMMARY Returns XML containing XML from each record in records
'##PARAM pRecords LDE.Records from Lime
'##RETURNS pRecords in XML-format
'----------------------------------
Private Sub GetXMLFromRecords(pRecords As LDE.Records, pLimeIDXML As MSXML2.DOMDocument60, pPool As LDE.Pool)
    On Error GoTo ErrorHandler
    Dim pRecord As LDE.Record
    Dim pRoot As MSXML2.IXMLDOMNode

    If pLimeIDXML Is Nothing Then
        Set pLimeIDXML = New MSXML2.DOMDocument60
        Set pRoot = pLimeIDXML.createElement("records")
        Call pLimeIDXML.appendChild(pRoot)
        Call pLimeIDXML.SetProperty("SelectionLanguage", "XPath")
    Else
        Set pRoot = pLimeIDXML.selectSingleNode("records")
    End If

    For Each pRecord In pRecords
        If pPool.count = 0 Then
            Call TrimAndLCaseAttributeValues(pRecord.xml)
            Call pRoot.appendChild(pRecord.xml)
        ElseIf Not pPool.Exists(pRecord.id) Then
            Call TrimAndLCaseAttributeValues(pRecord.xml)
            Call pRoot.appendChild(pRecord.xml)
        End If
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetXMLFromRecords" & vbCrLf & Err.Source, Err.Description)
End Sub

'----------------------------------
'##SUMMARY Inserts negative ID:s for new records and Lime ID for the ones to be updated.
'##PARAM pLimeIDXML Contains XML with Lime-IDs
'##PARAM pImportXML The data in XML format that will be imported
'##PARAM pView LDE.View containing keyfields
'##RETURNS True if successful
'----------------------------------
Private Function InsertExistingLimeIDInXML(pLimeIDXML As MSXML2.DOMDocument60, pImportXML As MSXML2.IXMLDOMNode, pView As LDE.View, strTableName As String, strTopNode As String, pSubTables As MSXML2.IXMLDOMNodeList, pImportLogXML As MSXML2.DOMDocument60, pTable As MSXML2.IXMLDOMNode) As Boolean
    On Error GoTo ErrorHandler
    Dim pImportNode As MSXML2.IXMLDOMNode
    Dim pLimeIDNode As MSXML2.IXMLDOMNode
    Dim pClonedImportNode As MSXML2.IXMLDOMNode
    Dim i As Integer
    Dim strSearchString As String
    Dim strFieldName As String
    Dim strValue As String
    Dim intHits As Integer
    Dim lngNewId As Long
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim lngOldId As Long
    Dim pInfoNodes As MSXML2.IXMLDOMNodeList
    Dim pInfoNode As MSXML2.IXMLDOMNode
    Dim pClonedInfoNode As MSXML2.IXMLDOMNode
    Dim intShowWorking As Integer

    lngNewId = -101

    For Each pImportNode In pImportXML.selectNodes("//" & strTopNode & "/" & strTableName)
        If m_WorkDialog.cancel Then
            Exit For
        End If
        Call ShowWorking(intShowWorking, 100)
        strSearchString = ""
        For i = 1 To pView.count
            strFieldName = pView.Item(i).FieldName

            If InStr(1, strFieldName, ".") > 0 Then
                strFieldName = Left(strFieldName, InStr(1, strFieldName, ".") - 1)
            End If

            If pImportNode.Attributes.getNamedItem(strFieldName) Is Nothing Then
                 strValue = ""
            Else
                strValue = Trim(LCase(pImportNode.Attributes.getNamedItem(strFieldName).Text))
            End If

            If Len(strSearchString) > 0 Then
                strSearchString = strSearchString & " and "
            Else
                strSearchString = "["
            End If
            strSearchString = strSearchString & "@" & strFieldName & "=""" & strValue & """"
        Next

        strSearchString = strSearchString & "]"
        If Not pLimeIDXML Is Nothing Then
            intHits = pLimeIDXML.selectNodes("//" & strTableName & strSearchString).Length
        Else
            intHits = 0
        End If

        If intHits > 0 Then
            i = 1
            Set pAttribute = pImportNode.Attributes.getNamedItem("id" & strTableName)
            lngOldId = pAttribute.Text


            For Each pLimeIDNode In pLimeIDXML.selectNodes("//" & strTableName & strSearchString)
                If m_WorkDialog.cancel Then
                    Exit For
                End If
                lngNewId = pLimeIDNode.Attributes.getNamedItem("id" & strTableName).Text

                If i = 1 Then
                    pAttribute.Text = lngNewId

                    If Not pImportLogXML Is Nothing Then
                        Set pInfoNodes = pImportLogXML.selectNodes("//error[@class='" & strTableName & "' and @classid='" & lngOldId & "' and @level='" & strTopNode & "']")
                        For Each pInfoNode In pInfoNodes
                            pInfoNode.Attributes.getNamedItem("classid").Text = lngNewId
                        Next
                    End If

                    If strTopNode = "main" Then
                        Call ChangeLimeIDForRelatedRecords(pImportXML, pSubTables, lngNewId, lngOldId)
                        lngOldId = lngNewId
                    End If
                Else
                    Set pClonedImportNode = pImportNode.cloneNode(True)
                    pAttribute.Text = lngNewId

                    If Not pImportLogXML Is Nothing Then
                        For Each pInfoNode In pInfoNodes
                            Set pClonedInfoNode = pInfoNode.cloneNode(True)
                            pClonedInfoNode.Attributes.getNamedItem("classid").Text = lngNewId
                            Call pImportLogXML.selectSingleNode("//errors").appendChild(pClonedInfoNode)
                        Next
                    End If

                    Call pImportXML.selectSingleNode(strTopNode).appendChild(pClonedImportNode)
                    If strTopNode = "main" Then
                        Call CreateNewRelatedNodes(pImportXML, pSubTables, lngNewId, lngOldId)
                    End If
                End If
                i = i + 1

                'MLY 2007-04-30
                If pTable.selectNodes("//table[@class='" & strTableName & "']/column[@type='18']").Length > 0 Then
                    Call GetValuesFromSetFieldsValue(pLimeIDNode, pImportNode, pTable, strTableName)
                End If
            Next
        End If
    Next

     Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::InsertExistingLimeIDInXML" & vbCrLf & Err.Source, Err.Description)
End Function

'MLY 2007-04-30
Private Sub GetValuesFromSetFieldsValue(pLimeIDNode As MSXML2.IXMLDOMNode, pImportNode As MSXML2.IXMLDOMNode, pTable As MSXML2.IXMLDOMNode, strTableName As String)
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim strValueFromLime As String
    Dim strValueFromImport As String
    Dim strNewValue As String
    Dim strArray() As String
    Dim i As Integer

    For Each pNode In pTable.selectNodes("//table[@class='" & strTableName & "']/column[@type='18']/@lime")
        If m_WorkDialog.cancel Then
            Exit For
        End If
        If pLimeIDNode.Attributes.getNamedItem(pNode.nodeValue) Is Nothing Then
            Exit For
        Else
            strValueFromLime = pLimeIDNode.Attributes.getNamedItem(pNode.nodeValue).Text
            If Not pImportNode.Attributes.getNamedItem(pNode.nodeValue) Is Nothing Then
                strArray = Split(pImportNode.Attributes.getNamedItem(pNode.nodeValue).Text, ";")

                If UBound(strArray) < 24 Then
                    For i = LBound(strArray) To UBound(strArray)
                        'MLY 2007-04-30
                        If Len(strArray(i)) > 0 Then
                            If Len(strValueFromLime) > 0 Then
                                strValueFromImport = ";" & strArray(i) & ";"
                                If InStr(1, strValueFromLime, strValueFromImport) = 0 Then
                                    strNewValue = GetMergeSetValue(strValueFromImport, strValueFromLime)
                                    pImportNode.Attributes.getNamedItem(pNode.nodeValue).Text = strNewValue
                                    pLimeIDNode.Attributes.getNamedItem(pNode.nodeValue).Text = strNewValue
                                End If
                            Else
                                strNewValue = ";" & strArray(i) & ";"
                                pImportNode.Attributes.getNamedItem(pNode.nodeValue).Text = strNewValue
                                pLimeIDNode.Attributes.getNamedItem(pNode.nodeValue).Text = strNewValue
                            End If
                        End If
                    Next
                End If
            End If
        End If
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetValuesFromSetFieldsValue" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Function GetMergeSetValue(strSingleValue As String, strSetValue As String) As String
    On Error GoTo ErrorHandler

    If InStr(1, strSetValue, strSingleValue) = 0 Then
        'MLY 2007-04-30 (If-satsen)
        If Len(strSetValue) > 0 Then
            GetMergeSetValue = Left(strSetValue, Len(strSetValue) - 1) & strSingleValue
        Else
            strSetValue = strSingleValue
        End If
    Else
        GetMergeSetValue = strSetValue
    End If


    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetMergeSetValue" & vbCrLf & Err.Source, Err.Description)
End Function


'----------------------------------
'##SUMMARY Creates new nodes for subtables when the import key has matched more than one record in Lime
'##PARAM pImportXML The data in XML format that will be imported
'##PARAM pSubTables Map information about subtables
'##PARAM lngNewID Lime ID
'##PARAM lngOldID Temporary ID to be used to find the node
'----------------------------------
Private Sub CreateNewRelatedNodes(pImportXML As MSXML2.IXMLDOMNode, pSubTables As MSXML2.IXMLDOMNodeList, lngNewId As Long, lngOldId As Long)
    On Error GoTo ErrorHandler
    Dim strLinkedField As String
    Dim strSubTable As String
    Dim pSubTable As MSXML2.IXMLDOMNode
    Dim pSubNode As MSXML2.IXMLDOMNode
    Dim pClonedSubNode As MSXML2.IXMLDOMNode

    For Each pSubTable In pSubTables
        If m_WorkDialog.cancel Then
            Exit For
        End If
        If Not pSubTable.Attributes.getNamedItem("linked") Is Nothing Then
            strLinkedField = pSubTable.Attributes.getNamedItem("linked").Text
            strSubTable = pSubTable.Attributes.getNamedItem("class").Text
            For Each pSubNode In pImportXML.selectNodes("//sub/" & strSubTable & "[@" & strLinkedField & "=""" & lngOldId & """]")
                If m_WorkDialog.cancel Then
                    Exit For
                End If
                Set pClonedSubNode = pSubNode.cloneNode(True)
                pClonedSubNode.Attributes.getNamedItem(strLinkedField).Text = lngNewId
                Call pImportXML.selectSingleNode("sub").appendChild(pClonedSubNode)

                pClonedSubNode.Attributes.getNamedItem("id" & strSubTable).Text = m_lngSubLimeID
                m_lngSubLimeID = m_lngSubLimeID - 1
            Next
        End If
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CreateNewRelatedNodes" & vbCrLf & Err.Source, Err.Description)
End Sub

'----------------------------------
'##SUMMARY Update Related noted with correct main table Lime ID
'##PARAM pImportXML The data in XML format that will be imported
'##PARAM pSubTables Map information about subtables
'##PARAM lngNewID Lime ID
'##PARAM lngOldID Temporary ID to be used to find the node
'----------------------------------
Private Sub ChangeLimeIDForRelatedRecords(pImportXML As MSXML2.IXMLDOMNode, pSubTables As MSXML2.IXMLDOMNodeList, lngNewId As Long, lngOldId As Long)
    On Error GoTo ErrorHandler
    Dim strLinkedField As String
    Dim strSubTable As String
    Dim pSubTable As MSXML2.IXMLDOMNode
    Dim pSubNode As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute

    For Each pSubTable In pSubTables
        If Not pSubTable.Attributes.getNamedItem("linked") Is Nothing Then
            strLinkedField = pSubTable.Attributes.getNamedItem("linked").Text
            strSubTable = pSubTable.Attributes.getNamedItem("class").Text
            For Each pSubNode In pImportXML.selectNodes("//sub/" & strSubTable & "[@" & strLinkedField & "=""" & lngOldId & """]")
                pSubNode.Attributes.getNamedItem(strLinkedField).Text = lngNewId

                Set pAttribute = pSubTable.ownerDocument.createAttribute("limeimport__existing")
                pAttribute.Text = "True"
                Call pSubNode.Attributes.setNamedItem(pAttribute)
            Next
        End If
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::ChangeLimeIDForRelatedRecords" & vbCrLf & Err.Source, Err.Description)
End Sub

'----------------------------------
'##SUMMARY Controls if all values specified as key and is a mandatory field contains a value
'----------------------------------
Private Function CheckKeyValues(ByVal pImportNode As MSXML2.IXMLDOMElement, ByVal pTable As MSXML2.IXMLDOMElement, pImportLogXML As MSXML2.DOMDocument60, strMainTableName As String, lngLineNo As Long) As Boolean
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim strTableName As String
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim blnKeysFilled As Boolean
    Dim strFieldName As String
    Dim strTopNode As String

    strTableName = pTable.GetAttribute("class")
    blnKeysFilled = True
    strTopNode = "sub"

    'MLY 2007-06-25 Changed - deleted required = '1'
    For Each pNode In pTable.selectNodes("column[@key='1']/@lime")
        If pImportNode.Attributes.getNamedItem(pNode.nodeValue) Is Nothing Then
            blnKeysFilled = False
            strFieldName = pNode.nodeValue
            Exit For
        ElseIf pImportNode.GetAttribute(pNode.nodeValue) = "" Then
            CheckKeyValues = False
            strFieldName = pNode.nodeValue
            Exit For
        End If
    Next

    If pTable.Attributes.getNamedItem("linked") Is Nothing Then
        strTopNode = "main"
    ElseIf pTable.Attributes.getNamedItem("linked").Text = "" Then
        strTopNode = "main"
    End If

    If Not blnKeysFilled Then
        Set pErrorRoot = GetErrorRoot(pImportLogXML, strTableName, strMainTableName, pTable.Attributes.getNamedItem("field").Text)
        Set pErrorNode = CreateErrorNode("key field empty", strTableName, strFieldName, strTopNode, pImportLogXML, strTopNode)
        Call pErrorNode.appendChild(pImportNode)

        Set pErrorNode = CreateErrorNode("deleted line", strTableName, strFieldName, strTopNode, pImportLogXML, strTopNode)
        Call pErrorNode.Attributes.setNamedItem(GetAttribute(CStr(lngLineNo), "lineno", pErrorNode.ownerDocument))
        Call pErrorNode.appendChild(pImportNode)

        Call pErrorRoot.appendChild(pErrorNode)
        Call AddDeletedInformation(pImportLogXML, strTableName, strTopNode, pTable.Attributes.getNamedItem("field").Text)
    End If

    CheckKeyValues = blnKeysFilled

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CheckKeyValues" & vbCrLf & Err.Source, Err.Description)
End Function


Public Sub SaveConfiguration(ByVal vtXml As Variant)
    On Error GoTo ErrorHandler

    Dim pDialog As LCO.FileSaveDialog
    Dim pFso As Scripting.FileSystemObject
    Dim pStream As Scripting.TextStream
    Dim sFileName As String

    Set pDialog = New LCO.FileSaveDialog
    pDialog.Filter = "XML-dokument (.xml)|*.xml"

    If pDialog.show = vbOK Then
        sFileName = pDialog.FileName

        Set pFso = New Scripting.FileSystemObject
        Set pStream = pFso.OpenTextFile(sFileName, ForWriting, True, TristateTrue)
        Call pStream.Write(vtXml.xml)
        Call pStream.Close
    End If

    Exit Sub
ErrorHandler:
    Call UI.ShowError("XmlImport.SaveConfiguration")
End Sub

Public Function SaveOverview(ByVal pXml As MSXML2.DOMDocument60) As String
    On Error GoTo ErrorHandler
    Dim pDialog As LCO.FileSaveDialog
    Dim sFileName As String
    Dim pXSLT As MSXML2.FreeThreadedDOMDocument60
    Dim pHTMLXml As MSXML2.DOMDocument60
    Dim strXML As String
    Dim strHTMLFilePath As String
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim strClassName As String
    Dim nFileNum As Long

    Set pDialog = New LCO.FileSaveDialog
    pDialog.Filter = "HTML-dokument (.htm)|*.htm"

    Application.MousePointer = 0
    If pDialog.show = vbOK Then
        sFileName = pDialog.FileName
        Application.MousePointer = 11
        Set pXSLT = New MSXML2.FreeThreadedDOMDocument60
        pXSLT.async = False
        pXSLT.SetProperty "SelectionLanguage", "XPath"
        pXSLT.SetProperty "SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'"

        For Each pNode In pXml.selectNodes("//container")
            strClassName = pNode.Attributes.getNamedItem("class").Text
            If Database.Classes.Exists(strClassName) Then
                strClassName = Database.Classes(strClassName).LocalName
            End If
            Call pNode.Attributes.setNamedItem(GetAttribute(strClassName, "localname", pXml))
        Next

        If pXSLT.Load(Application.WebFolder & STRLOGFILEPATH & "xsl\createrecord_" & Application.Locale & ".xsl") Then
            strXML = pXml.transformNode(pXSLT)
            If VBA.Len(strXML) > 0 Then
                nFileNum = FreeFile
                Open sFileName For Output As #nFileNum
                Print #nFileNum, strXML
                SaveOverview = sFileName
            End If
        Else
            SaveOverview = ""
        End If

    End If

ExitHandler:
    On Error Resume Next
    Close #nFileNum
    Exit Function
ErrorHandler:
    Call UI.ShowError("XmlImport.SaveOverview")
    Resume ExitHandler
End Function


Private Function AddNodeFromRecordset(ByVal pImportXML As MSXML2.IXMLDOMElement, ByVal pTable As MSXML2.IXMLDOMElement, ByVal pRecordset As ADODB.Recordset, pImportLogXML As MSXML2.DOMDocument60, lngMainLimeID As Long, strMainTableName As String, lngCounter As Long, Optional lngSubLimeID As Long = 0) As Boolean
    On Error GoTo ErrorHandler
    Dim pElement As MSXML2.IXMLDOMElement
    Dim strValue As String
    Dim pRecordXML As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim pLinkedAttribute As MSXML2.IXMLDOMAttribute
    Dim blnNodeAdded As Boolean
    Dim blnValueFoundInRow As Boolean
    Dim strTopNode As String

    blnValueFoundInRow = False
    blnNodeAdded = False
    strTopNode = "sub"
    For Each pElement In pTable.childNodes
        If pRecordXML Is Nothing Then
            Set pRecordXML = pImportXML.ownerDocument.createElement(pTable.GetAttribute("class"))
            Set pAttribute = pImportXML.ownerDocument.createAttribute("id" & pTable.GetAttribute("class"))
            If lngSubLimeID = 0 Then
                pAttribute.Text = lngMainLimeID
                strTopNode = "main"
            Else
                pAttribute.Text = lngSubLimeID
                Set pLinkedAttribute = pImportXML.ownerDocument.createAttribute(pTable.GetAttribute("linked"))
                pLinkedAttribute.Text = lngMainLimeID
                Call pRecordXML.Attributes.setNamedItem(pLinkedAttribute)
            End If
            Call pRecordXML.Attributes.setNamedItem(pAttribute)
        End If

        If IsNull(pRecordset.Fields(pElement.GetAttribute("alias")).Value) Then
            strValue = ""
        Else
            strValue = pRecordset.Fields(pElement.GetAttribute("alias")).Value
            blnValueFoundInRow = True
        End If


        Select Case pElement.GetAttribute("type")
            Case CStr(lkFieldTypeLink):
                strValue = GetRelationFieldValue(pElement, strValue)

            Case CStr(lkFieldTypeOption), CStr(lkFieldTypeSet):
                strValue = GetOptionValue(pElement, strValue)

            Case CStr(lkFieldTypeYesNo):
                strValue = GetYesNoValue(pElement, strValue)

            Case CStr(lkFieldTypeCurrency), CStr(lkFieldTypeDecimal), CStr(lkFieldTypeGrade), CStr(lkFieldTypePercent)
                strValue = Replace(strValue, ",", ".")
        End Select

        ' If there isn't a value, try to get the default value
        If strValue = "" Then
            If pElement.GetAttribute("type") = lkFieldTypeYesNo Then
                strValue = pElement.GetAttribute("default") - 100
            Else
                strValue = pElement.GetAttribute("default")
            End If
            If pElement.GetAttribute("type") = lkFieldTypeOption Or pElement.GetAttribute("type") = lkFieldTypeSet Then
                If strValue = "0" Then
                    strValue = ""
                End If
            End If
        End If


        If Len(strValue) > 0 Then
            Set pAttribute = pImportXML.ownerDocument.createAttribute(pElement.GetAttribute("lime"))
            pAttribute.Text = strValue
            Call pRecordXML.Attributes.setNamedItem(pAttribute)
        End If
    Next

    If blnValueFoundInRow Then
        Call CheckFieldRules(pRecordXML, pImportLogXML, pTable, strTopNode, strMainTableName)
        If CheckKeyValues(pRecordXML, pTable, pImportLogXML, strMainTableName, lngCounter) Then
            If Not pRecordXML Is Nothing Then
                Call pImportXML.appendChild(pRecordXML)
                blnNodeAdded = True
            End If
        End If
    End If

    AddNodeFromRecordset = blnNodeAdded

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::AddNodeFromRecordset" & vbCrLf & Err.Source, Err.Description)
End Function

Private Function GetYesNoValue(ByVal pColumn As MSXML2.IXMLDOMElement, ByVal Value As Variant) As Variant
    On Error GoTo ErrorHandler
    Dim OptionsNode As MSXML2.IXMLDOMElement
    Dim OptionNode As MSXML2.IXMLDOMElement
    Dim strSearchString As String

    GetYesNoValue = Null

    Set OptionsNode = pColumn.ownerDocument.selectSingleNode(Application.FormatString("/import/options[@columnalias='%1']", pColumn.GetAttribute("alias")))

    If Not OptionsNode Is Nothing Then
        strSearchString = Application.FormatString("option[@file=""%1""]", CStr(Value))
        Set OptionNode = OptionsNode.selectSingleNode(strSearchString)


        If Not OptionNode Is Nothing Then
            GetYesNoValue = OptionNode.GetAttribute("lime") - 100
        End If

        If IsNull(GetYesNoValue) Then
            GetYesNoValue = ""
        End If
    End If

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetYesNoValue" & vbCrLf & Err.Source, Err.Description)
End Function

Private Sub SortColumns(ByVal pHeaders As Scripting.Dictionary)
    On Error GoTo ErrorHandler
    Dim arrHeaders() As String

    Const cSortField As String = "name"
    Const cMaxLength As String = 256

    Dim pAdoRs As New ADODB.Recordset
    Dim nIndex As Long

    ' Setup the recordset
    Set pAdoRs = New ADODB.Recordset
    Call pAdoRs.Fields.Append(cSortField, adVarChar, cMaxLength)
    Call pAdoRs.Open(Nothing, Nothing, ADODB.adOpenDynamic)
    pAdoRs.Sort = Replace("[%1] ASC", "%1", cSortField)

    For nIndex = 0 To pHeaders.count - 1
        Call pAdoRs.AddNew
        pAdoRs.Fields(cSortField).Value = pHeaders.Keys(nIndex)
    Next nIndex

    Call pAdoRs.Update
    Call pAdoRs.MoveFirst
    Call pHeaders.RemoveAll

    While Not pAdoRs.EOF
        Call pHeaders.Add(CStr(pAdoRs.Fields(cSortField).Value), "")
        Call pAdoRs.MoveNext
    Wend

    pAdoRs.Close

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::SortColumns" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Function GetErrorRoot(pImportLogXML As MSXML2.DOMDocument60, strTableName As String, strMainTableName As String, strLinkedFieldInMain As String) As MSXML2.IXMLDOMNode
    On Error GoTo ErrorHandler
    Dim pRoot As MSXML2.IXMLDOMNode
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pTableNode As MSXML2.IXMLDOMNode

    If pImportLogXML Is Nothing Then
        Set pImportLogXML = New MSXML2.DOMDocument60
        Set pRoot = pImportLogXML.createElement("importinfo")
        Call pImportLogXML.appendChild(pRoot)
    End If

    If pRoot Is Nothing Then
        Set pRoot = pImportLogXML.selectSingleNode("//importinfo")
    End If

    If pImportLogXML.selectSingleNode("//errors") Is Nothing Then
        Set pErrorRoot = pImportLogXML.createElement("errors")
        Call pRoot.appendChild(pErrorRoot)
    End If

    If pErrorRoot Is Nothing Then
        Set pErrorRoot = pImportLogXML.selectSingleNode("//errors")
    End If

    Set pTableNode = pErrorRoot.selectSingleNode(strTableName & "." & strLinkedFieldInMain)

    If pTableNode Is Nothing Then
        Set pTableNode = pImportLogXML.createElement(strTableName & "." & strLinkedFieldInMain)
        If Len(strLinkedFieldInMain) > 0 Then
            Call pTableNode.Attributes.setNamedItem(GetAttribute(Database.Classes(strMainTableName).Fields(strLinkedFieldInMain).LocalName, "localname", pImportLogXML))
        Else
            Call pTableNode.Attributes.setNamedItem(GetAttribute(Database.Classes(strMainTableName).LocalName, "localname", pImportLogXML))
        End If
        Call pErrorRoot.appendChild(pTableNode)
    End If

    Set GetErrorRoot = pTableNode

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetErrorNode" & vbCrLf & Err.Source, Err.Description)
End Function

Private Function GetImportRoot(pImportLogXML As MSXML2.DOMDocument60) As MSXML2.IXMLDOMNode
    On Error GoTo ErrorHandler
    Dim pImportRoot As MSXML2.IXMLDOMNode
    Dim pRoot As MSXML2.IXMLDOMNode

    If pImportLogXML Is Nothing Then
        Set pImportLogXML = New MSXML2.DOMDocument60
        Set pRoot = pImportLogXML.createElement("importinfo")
        Call pImportLogXML.appendChild(pRoot)
    End If

    If pRoot Is Nothing Then
        Set pRoot = pImportLogXML.selectSingleNode("//importinfo")
    End If

    If pImportLogXML.selectSingleNode("//imports") Is Nothing Then
        Set pImportRoot = pImportLogXML.createElement("imports")
        Call pRoot.appendChild(pImportRoot)
    End If

    If pImportRoot Is Nothing Then
        Set pImportRoot = pImportLogXML.selectSingleNode("//imports")
    End If

    Set GetImportRoot = pImportRoot

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetImportRoot" & vbCrLf & Err.Source, Err.Description)
End Function



'-----------------------------------------------
' ##SUMMARY Returns an XML-attribute with name and value
' ##PARAM strValue Attribute value
' ##PARAM strAttributeName Attribute name
' ##PARAM pXML DomDocument to use to create attribute
' ##RETURNS XMLDOM Attribute
'-----------------------------------------------
Private Function GetAttribute(strValue As String, strAttributeName As String, pXml As MSXML2.DOMDocument60) As MSXML2.IXMLDOMAttribute
    On Error GoTo ErrorHandler
    Dim pAttribute As MSXML2.IXMLDOMAttribute

    Set pAttribute = pXml.createAttribute(strAttributeName)
    pAttribute.Text = strValue

    Set GetAttribute = pAttribute

    Exit Function
ErrorHandler:
    Set GetAttribute = Nothing
    Call Err.Raise(Err.Number, "XmlImport::GetAttribute" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Creates error node (used to ImportLog.htm)
' ##PARAM strErrorType Type of error:<BR>empty mandatory field<BR>option error<BR>set error<BR>min error<BR>max error<BR>length error<BR>
' ##PARAM strTableName Name of Lime class
' ##PARAM strFieldName Name of Lime field
' ##PARAM strLimeid ID of Lime record
' ##PARAM pImportLogXML XML containing server rule errors
' ##RETURNS A new XML errornode
'-----------------------------------------------
Private Function CreateErrorNode(strErrorType As String, strTableName As String, strFieldName As String, strLimeID As String, pImportLogXML As MSXML2.DOMDocument60, strTopNode As String) As MSXML2.IXMLDOMNode
    On Error GoTo ErrorHandler
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim pNode As MSXML2.IXMLDOMNode

    Set pErrorNode = pImportLogXML.createElement("error")

    Call pErrorNode.Attributes.setNamedItem(GetAttribute(strErrorType, "errortype", pImportLogXML))
    Call pErrorNode.Attributes.setNamedItem(GetAttribute(strTableName, "class", pImportLogXML))
    Call pErrorNode.Attributes.setNamedItem(GetAttribute(strLimeID, "classid", pImportLogXML))
    Call pErrorNode.Attributes.setNamedItem(GetAttribute(strFieldName, "field", pImportLogXML))
    Call pErrorNode.Attributes.setNamedItem(GetAttribute(Database.Classes(strTableName).Fields(strFieldName).LocalName, "localnamefield", pImportLogXML))
    Call pErrorNode.Attributes.setNamedItem(GetAttribute(strTopNode, "level", pImportLogXML))

    Set CreateErrorNode = pErrorNode

    Exit Function
ErrorHandler:
    Set CreateErrorNode = Nothing
    Call Err.Raise(Err.Number, "XmlImport::CreateErrorNode" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Create import log HTML file
' ##PARAM pImportLogXML XML containing server rule errors
' ##RETURNS True if successful.
'-----------------------------------------------
Private Function CreateImportLog(pImportLogXML As MSXML2.DOMDocument60) As String
    On Error GoTo ErrorHandler
    Dim pXSLT As MSXML2.FreeThreadedDOMDocument60
    Dim pHTMLXml As MSXML2.DOMDocument60
    Dim strXML As String
    Dim strHTMLFilePath As String
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute

    Set pXSLT = New MSXML2.FreeThreadedDOMDocument60
    pXSLT.async = False
    pXSLT.SetProperty "SelectionLanguage", "XPath"
    pXSLT.SetProperty "SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'"

    For Each pNode In pImportLogXML.selectNodes("//errors/*/error")
        Set pAttribute = pImportLogXML.createAttribute("link")
        If Not pNode.Attributes.getNamedItem("class") Is Nothing And Not pNode.Attributes.getNamedItem("classid") Is Nothing Then
            pAttribute.Text = "limecrm:" & pNode.Attributes.getNamedItem("class").Text & "." & Database.Name & "." & Database.RemoteServerName & "?" & pNode.Attributes.getNamedItem("classid").Text
        End If
        Call pNode.Attributes.setNamedItem(pAttribute)
    Next

    If pXSLT.Load(Application.WebFolder & STRLOGFILEPATH & "xsl\importlog.xsl") Then
        strXML = pImportLogXML.transformNode(pXSLT)

        If VBA.Len(strXML) > 0 Then
            Set pHTMLXml = New MSXML2.DOMDocument60
            If pHTMLXml.loadXML(strXML) Then
                CreateImportLog = WriteXMLToFile(pHTMLXml, "ImportLog.htm", False)
            Else
                CreateImportLog = ""
            End If
        End If
    Else
        CreateImportLog = ""
    End If

    Exit Function
ErrorHandler:
    CreateImportLog = ""
    Call Err.Raise(Err.Number, "XmlImport::CreateImportLog" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY  Write XML to file
' ##PARAM pXMLDoc XML document to be saved.
' ##PARAM strLogFileName Name of the file to be saved
' ##PARAM blnAddXMLVersion If XML-header should be added first in the saves file.
' ##RETURNS True if successful
'-----------------------------------------------
Private Function WriteXMLToFile(pXMLDoc As MSXML2.DOMDocument60, strLogFileName As String, blnAddXMLVersion As Boolean) As String
    On Error GoTo ErrorHandler
    Dim nFileNum As Long
    Dim sFileName As String
    Dim strFolder As String

    If Not pXMLDoc Is Nothing Then
        strFolder = LCO.MakeFileName(Application.WebFolder, STRLOGFILEPATH)
        If FolderExists(strFolder) Then
            nFileNum = FreeFile

            strLogFileName = LCO.MakeFileName(strFolder, strLogFileName)

            Open strLogFileName For Output As #nFileNum
            If blnAddXMLVersion Then
                Print #nFileNum, "<?xml version=""1.0"" encoding=""ISO-8859-1""?>" & pXMLDoc.xml
            Else
                Print #nFileNum, pXMLDoc.xml
            End If

            WriteXMLToFile = strLogFileName
        Else
            WriteXMLToFile = ""
        End If
    End If

CloseHandler:
    On Error Resume Next
    Close #nFileNum
    Exit Function
ErrorHandler:
    WriteXMLToFile = ""
    Call Err.Raise(Err.Number, "XmlImport::WriteXMLToFile" & vbCrLf & Err.Source, Err.Description)
    Resume CloseHandler
End Function
'-----------------------------------------------
' ##SUMMARY Checks if folder exists, if not - folder is created
' ##PARAM strFolderPath Folderpath
' ##RETURNS True if successful.
'-----------------------------------------------
Private Function FolderExists(strFolderPath As String) As Boolean
    On Error GoTo ErrorHandler
    Dim pFso As New Scripting.FileSystemObject
    Dim pFolder As Scripting.folder

    If pFso.FolderExists(strFolderPath) Then
        FolderExists = True
    Else
        Set pFolder = pFso.CreateFolder(strFolderPath)
        If Not pFolder Is Nothing Then
            FolderExists = True
        Else
            FolderExists = False
        End If
    End If

    Exit Function
ErrorHandler:
    FolderExists = False
    Call Err.Raise(Err.Number, "XmlImport::FolderExists" & vbCrLf & Err.Source, Err.Description)
End Function




'-------------------------------------------
' --- IMPORT FUNCTIONS
'-------------------------------------------

Public Function RunImport(ByVal pXmlDocument As MSXML2.DOMDocument60) As Boolean
    On Error GoTo ErrorHandler

    m_lngCoworkerRandomizedNumber = -1
    Set m_pXmlDocument = pXmlDocument
    Set m_WorkDialog = New LCO.WorkDialog
    Call SetWorkDialogSettings(False, True)

    Call m_WorkDialog.show
    'Call StartUpImport

    RunImport = Not m_WorkDialog.cancel

    Exit Function
ErrorHandler:
    Call UI.ShowError("XmlImport::RunImport" & vbCrLf & Err.Source)
    RunImport = False
End Function

Private Sub m_WorkDialog_Work()
    On Error GoTo ErrorHandler
    Call StartUpImport
    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, Err.Source, Err.Description)
End Sub

Private Sub StartUpImport()
    On Error GoTo ErrorHandler
    Dim pRecordset As ADODB.Recordset
    Dim pXMLDoc As MSXML2.DOMDocument60
    Dim pMainTableNode As MSXML2.IXMLDOMNode
    Dim pSubTableNodes As MSXML2.IXMLDOMNodeList
    Dim blnOnlyInsert As Boolean
    Dim pImportXML As MSXML2.IXMLDOMNode
    Dim pViewCol As Scripting.Dictionary
    Dim pSubTable As MSXML2.IXMLDOMElement
    Dim strMainTableName As String
    Dim pMainRoot As MSXML2.IXMLDOMNode
    Dim pSubRoot As MSXML2.IXMLDOMNode
    Dim pImportLogXML As MSXML2.DOMDocument60
    Dim pLimeIDXML As MSXML2.DOMDocument60
    Dim pExecutedLimeXML As MSXML2.DOMDocument60
    Dim strSubTable As String
    Dim strLinkedField As String
    Dim strFormat As String
    Dim strImportLogFile As String
    Dim strLinkedFieldInMain As String
    Dim strTableNameToShowUser As String
    Dim dteStartTime As Date
    Dim dteEndTime As Date
    Dim intShowWorking As Integer
    Dim lngCounter As Long

    dteStartTime = Now()
    Application.MousePointer = 11

    strFormat = m_pXmlDocument.selectSingleNode("//import").Attributes.getNamedItem("fileformat").Text
    Set pXMLDoc = New MSXML2.DOMDocument60
    Set pMainTableNode = m_pXmlDocument.selectSingleNode("/import/table[@field='']")
    Set pSubTableNodes = m_pXmlDocument.selectNodes("/import/table[@field!='']")
    Set pImportXML = pXMLDoc.createElement("records")
    Set pMainRoot = pXMLDoc.createElement("main")
    Set pSubRoot = pXMLDoc.createElement("sub")
    Set pViewCol = GetViews(pMainTableNode, pSubTableNodes)
    Set pRecordset = OpenRecordsetFromFile(m_pXmlDocument, m_sImportFile, strFormat)

    m_dblRaiseProgresCheckSteps = 20 / (1 + pSubTableNodes.Length)

    m_lngMainLimeID = -101
    m_lngSubLimeID = -101
    strMainTableName = pMainTableNode.Attributes.getNamedItem("class").Text

    Call pImportXML.appendChild(pMainRoot)
    Call pImportXML.appendChild(pSubRoot)

    Call SetWorkDialogText("readFile")
    While Not pRecordset.EOF And Not m_WorkDialog.cancel
        lngCounter = lngCounter + 1
        Call ShowWorking(intShowWorking, 500)
        If AddNodeFromRecordset(pMainRoot, pMainTableNode, pRecordset, pImportLogXML, m_lngMainLimeID, strMainTableName, lngCounter) Then
            For Each pSubTable In pSubTableNodes
                If AddNodeFromRecordset(pSubRoot, pSubTable, pRecordset, pImportLogXML, m_lngMainLimeID, strMainTableName, lngCounter, m_lngSubLimeID) Then
                    m_lngSubLimeID = m_lngSubLimeID - 1
                End If
            Next
            m_lngMainLimeID = m_lngMainLimeID - 100
        End If
        pRecordset.MoveNext
    Wend
    Call SetWorkDialogProgressBar(0, 5)

    If Not m_WorkDialog.cancel Then
        If pImportXML.firstChild.childNodes.Length > 0 Then
            'Check and insert maintable lines
            strTableNameToShowUser = Database.Classes(strMainTableName).LocalName
            Call SetWorkDialogText("checkRecords", strTableNameToShowUser)
            Set pLimeIDXML = GetXMLWithExistingLimeID(pImportXML, pViewCol(strMainTableName), strMainTableName, "main", pMainTableNode)

            If Not m_WorkDialog.cancel Then
                If Not pLimeIDXML Is Nothing Then
                    Call InsertExistingLimeIDInXML(pLimeIDXML, pImportXML, pViewCol(strMainTableName), strMainTableName, "main", pSubTableNodes, pImportLogXML, pMainTableNode)
                End If

                If Not m_WorkDialog.cancel Then
                    If CheckAndFixMandatoryRules(pImportXML.selectSingleNode("main"), strMainTableName, "main", pImportLogXML, strMainTableName, "") Then
                        Call MergeIfSameInsertLine(pImportXML, pMainTableNode, strMainTableName, "main", pSubTableNodes, pImportLogXML)
                        If pImportXML.selectNodes("//*/*").Length > 0 Then
                            m_dblRaiseProgressImportSteps = 60 / (pImportXML.selectNodes("//*/*").Length)
                        Else
                            m_dblRaiseProgressImportSteps = 60
                        End If

                        Call SetWorkDialogSettings(False, False)
                        Call SetWorkDialogProgressBar(m_dblRaiseProgresCheckSteps)
                        Set pExecutedLimeXML = ExecuteXMLIntoLime(pImportXML.selectSingleNode("main"), pImportLogXML, "main", strMainTableName, strMainTableName, strLinkedFieldInMain, strTableNameToShowUser)

                        'Check and insert subtables lines
                        For Each pSubTable In pSubTableNodes
                            strSubTable = pSubTable.Attributes.getNamedItem("class").Text
                            strLinkedField = pSubTable.Attributes.getNamedItem("linked").Text
                            strLinkedFieldInMain = pSubTable.Attributes.getNamedItem("field").Text
                            strTableNameToShowUser = Database.Classes(strMainTableName).Fields(strLinkedFieldInMain).LocalName
                            Call SetWorkDialogText("checkRecords", strTableNameToShowUser)

                            If Not pExecutedLimeXML Is Nothing Then
                                If pExecutedLimeXML.childNodes.Length > 0 Then
                                    Call ReplaceMainIDInSubTables(pImportXML, pExecutedLimeXML, pSubTable, strLinkedField)
                                End If
                            End If

                            Set pLimeIDXML = GetXMLWithExistingLimeID(pImportXML, pViewCol(strSubTable & "." & strLinkedFieldInMain), strSubTable, "sub", pSubTable)

                            If Not pLimeIDXML Is Nothing Then
                                Call InsertExistingLimeIDInXML(pLimeIDXML, pImportXML, pViewCol(strSubTable & "." & strLinkedFieldInMain), strSubTable, "sub", Nothing, pImportLogXML, pSubTable)
                            End If

                            If CheckAndFixMandatoryRules(pImportXML.selectSingleNode("sub"), strSubTable, "sub", pImportLogXML, strMainTableName, strLinkedFieldInMain) Then
                                Call MergeIfSameInsertLine(pImportXML, pSubTable, strSubTable, "sub", Nothing, pImportLogXML)
                                m_dblRaiseProgressImportSteps = 50 / (pImportXML.selectNodes("//*/*").Length)
                                Call SetWorkDialogProgressBar(m_dblRaiseProgresCheckSteps)
                                Call ExecuteXMLIntoLime(pImportXML.selectSingleNode("sub"), pImportLogXML, "sub", strSubTable, strMainTableName, strLinkedFieldInMain, strTableNameToShowUser)
                            End If
                        Next
                        dteEndTime = Now()
                    End If
                End If
            End If
        Else
            Call Lime.MessageBox(Application.GetText("textfileimport", "noRecordsImported", "alert"))
        End If

        If Not m_WorkDialog.cancel Then
            If Not pImportLogXML Is Nothing Then
                Call DeleteLogFile
                Call pImportLogXML.selectSingleNode("importinfo").Attributes.setNamedItem(GetAttribute(m_sImportFile, "filepath", pImportLogXML))
                Call pImportLogXML.selectSingleNode("importinfo").Attributes.setNamedItem(GetAttribute(CStr(dteStartTime), "start", pImportLogXML))
                Call pImportLogXML.selectSingleNode("importinfo").Attributes.setNamedItem(GetAttribute(CStr(dteEndTime), "end", pImportLogXML))
                Call pImportLogXML.selectSingleNode("importinfo").Attributes.setNamedItem(GetAttribute(VBA.Round(VBA.DateDiff("s", dteStartTime, dteEndTime) / 60, 2), "diffMinutes", pImportLogXML))
                strImportLogFile = CreateImportLog(pImportLogXML)
                If Len(strImportLogFile) > 0 Then
                    Application.Panes.Visible = True
                    Call Application.Panes.Add("Importlogg", , strImportLogFile, lkPaneStylePersistentURL)
                    Set Application.Panes.ActivePane = Application.Panes.Item(Application.Panes.count)
                End If


            End If
            Call SetWorkDialogProgressBar(0, 100)
            Application.MousePointer = 0
            Call Application.ActiveExplorer.Requery(True)
        End If
    End If

    If m_WorkDialog.cancel Then
        Call Lime.MessageBox(Application.GetText("textfileimport", "importCancelled", "alert"))
    End If

    Call DeleteLogFile

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::WorkDialog_Work" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Sub DeleteLogFile()
    Dim pFso As New Scripting.FileSystemObject

     If pFso.FileExists(Application.WebFolder & STRLOGFILEPATH & "ImportLog.htm") Then
        Call pFso.DeleteFile(Application.WebFolder & STRLOGFILEPATH & "ImportLog.htm", True)
    End If
End Sub

Private Function TranslateText(TagName As String) As String
  TranslateText = "translate(" & TagName & ",'ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖÜÀÉÈ','abcdefghijklmnopqrstuvwxyzåäöüàéè')"
End Function


Private Sub MergeIfSameInsertLine(pImportXML As MSXML2.IXMLDOMNode, pTableNode As MSXML2.IXMLDOMNode, strTableName As String, strTopNode As String, pSubTables As MSXML2.IXMLDOMNodeList, pImportLogXML As MSXML2.DOMDocument60)
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim pSearchNode As MSXML2.IXMLDOMNode
    Dim pMergeNode As MSXML2.IXMLDOMNode
    Dim strSeachString As String
    Dim i As Integer
    Dim strLimeID As String
    Dim strMergeNodeID As String
    Dim pSubTable As MSXML2.IXMLDOMNode
    Dim strLinkedField As String
    Dim strSubTableName As String
    Dim pSubNode As MSXML2.IXMLDOMNode
    Dim pHitList As MSXML2.IXMLDOMNodeList
    Dim strLinkedFieldInMain As String
    Dim pInfoNode As MSXML2.IXMLDOMNode
    Dim intShowWorking As Integer
    Dim blnLimeIdAdded As Boolean

    If pTableNode.selectNodes("column[@key='1']/@lime").Length > 0 Then
       ' For Each pNode In pImportXML.selectNodes("//" & strTableName & "[@id" & strTableName & " < '0']")
        For Each pNode In pImportXML.selectNodes("//" & strTableName)
            If m_WorkDialog.cancel Then
                Exit For
            End If
            Call ShowWorking(intShowWorking, 100)
            strSeachString = "["
            For Each pSearchNode In pTableNode.selectNodes("column[@key='1']/@lime")
                If Len(strSeachString) > 1 Then
                    strSeachString = strSeachString & " and "
                End If
                If pNode.Attributes.getNamedItem(pSearchNode.nodeValue) Is Nothing Then
                    strSeachString = strSeachString & "@" & pSearchNode.nodeValue & " = ''"
                Else
                    If InStr(1, pNode.Attributes.getNamedItem(pSearchNode.nodeValue).Text, "'") Then
                        strSeachString = strSeachString & TranslateText("@" & pSearchNode.nodeValue) & " = """ & LCase(pNode.Attributes.getNamedItem(pSearchNode.nodeValue).Text) & """"
                    Else
                        strSeachString = strSeachString & TranslateText("@" & pSearchNode.nodeValue) & " = '" & LCase(pNode.Attributes.getNamedItem(pSearchNode.nodeValue).Text) & "'"
                    End If
                End If
            Next
            If strTopNode = "sub" Then
                strLinkedField = pTableNode.Attributes.getNamedItem("linked").Text
                strSeachString = strSeachString & " and @" & strLinkedField & " = '" & pNode.Attributes.getNamedItem(strLinkedField).Text & "'"
            End If


            'blnLimeIdAdded ny från 2007-06-13 MLY
            If pNode.Attributes.getNamedItem("id" & strTableName).Text > 0 Then
                strSeachString = strSeachString & " and @id" & strTableName & "='" & pNode.Attributes.getNamedItem("id" & strTableName).Text & "'"
                blnLimeIdAdded = True
            Else
                blnLimeIdAdded = False
            End If
            strSeachString = strSeachString & "]"

            If pImportXML.selectNodes("//" & strTopNode & "/" & strTableName & strSeachString).Length > 1 Then
                i = 0
                Set pHitList = pImportXML.selectNodes("//" & strTopNode & "/" & strTableName & strSeachString)
                For Each pMergeNode In pHitList
                    If m_WorkDialog.cancel Then
                        Exit For
                    End If
                    If i = 0 Then
                        strLimeID = pMergeNode.Attributes.getNamedItem("id" & strTableName).Text
                        Call MergeSetNode(pTableNode, pMergeNode, pHitList, strTableName)
                    ElseIf Not blnLimeIdAdded Then
                        strMergeNodeID = pMergeNode.Attributes.getNamedItem("id" & strTableName).Text

                        If strTopNode = "main" Then
                            For Each pSubTable In pSubTables
                                strSubTableName = pSubTable.Attributes.getNamedItem("class").Text
                                strLinkedField = pSubTable.Attributes.getNamedItem("linked").Text
                                strLinkedFieldInMain = pSubTable.Attributes.getNamedItem("field").Text
                                For Each pSubNode In pImportXML.selectNodes("//sub/" & strSubTableName & "[@" & strLinkedField & "='" & strMergeNodeID & "']")
                                    pSubNode.Attributes.getNamedItem(strLinkedField).Text = strLimeID
                                Next
                            Next
                        End If
                        Call pMergeNode.parentNode.removeChild(pMergeNode)
                        strLinkedFieldInMain = pTableNode.Attributes.getNamedItem("field").Text
                        If Not pImportLogXML Is Nothing Then
                            For Each pInfoNode In pImportLogXML.selectNodes("//errors/" & strTableName & "." & strLinkedFieldInMain & "/error" & "[@level='" & strTopNode & "' and @class='" & strTableName & "' and @classid='" & strMergeNodeID & "']")
                                Call pInfoNode.parentNode.removeChild(pInfoNode)
                            Next
                        End If
                    End If
                    i = i + 1
                Next
            End If
        Next
    End If

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::MergeIfSameInsertLime" & vbCrLf & Err.Source, Err.Description)
End Sub


Private Sub MergeSetNode(pTableNode As MSXML2.IXMLDOMNode, pMergeNode As MSXML2.IXMLDOMNode, pHitList As MSXML2.IXMLDOMNodeList, strTableName As String)
    On Error GoTo ErrorHandler
    Dim strMergeValue As String
    Dim pSetNode As MSXML2.IXMLDOMNode
    Dim pNode As MSXML2.IXMLDOMNode

    For Each pSetNode In pTableNode.selectNodes("column[@type='18']/@lime")
        strMergeValue = ";"

        For Each pNode In pHitList
            If Not pNode.Attributes.getNamedItem(pSetNode.nodeValue) Is Nothing Then
                strMergeValue = GetMergeSetValue(pNode.Attributes.getNamedItem(pSetNode.nodeValue).Text, strMergeValue)
            End If
        Next

        Call SetLimeSetAttribute(pMergeNode, pSetNode.nodeValue, strMergeValue)

    Next
    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::MergeSetNode" & vbCrLf & Err.Source, Err.Description)
End Sub


Private Sub SetLimeSetAttribute(pNode As MSXML2.IXMLDOMNode, strAttributeName As String, strValue As String)
    On Error GoTo ErrorHandler
    Dim pAttribute As MSXML2.IXMLDOMAttribute

    If pNode.Attributes.getNamedItem(strAttributeName) Is Nothing Then
        Set pAttribute = pNode.ownerDocument.createAttribute(strAttributeName)
        pAttribute.Text = strValue
        Call pNode.Attributes.setNamedItem(pAttribute)
    Else
        pNode.Attributes.getNamedItem(strAttributeName).Text = strValue
    End If

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::SetLimeSetAttribute" & vbCrLf & Err.Source, Err.Description)
End Sub

Private Sub ReplaceMainIDInSubTables(pImportXML As MSXML2.IXMLDOMNode, pExecutedLimeXML As MSXML2.DOMDocument60, pSubTable As MSXML2.IXMLDOMNode, strLinkedField As String)
    On Error GoTo ErrorHandler
    Dim pExecutedNode As MSXML2.IXMLDOMNode
    Dim pSubNode As MSXML2.IXMLDOMNode
    Dim lngOldId As Long
    Dim lngNewId As Long

    For Each pExecutedNode In pExecutedLimeXML.selectNodes("//record[@idold < '0']")
        lngOldId = pExecutedNode.Attributes.getNamedItem("idold").Text
        lngNewId = pExecutedNode.Attributes.getNamedItem("idnew").Text
        For Each pSubNode In pImportXML.selectNodes("//sub/*[@" & strLinkedField & " = '" & lngOldId & "']")
            pSubNode.Attributes.getNamedItem(strLinkedField).Text = lngNewId
        Next
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::ReplaceMainIDInSubTables" & vbCrLf & Err.Source, Err.Description)
End Sub

'--------------------------------------------------------
'##SUMMARY Creates view to be used to check if record already in database
'##PARAM pTableNode XML information about imported table and its "columns"
'##RETURNS LDE.View with keyvalues to get from Lime
'--------------------------------------------------------
Private Function GetView(ByVal pTableNode As MSXML2.IXMLDOMNode, blnIsSubTable As Boolean, strMainTableName As String) As LDE.View
    On Error GoTo ErrorHandler
    Dim pView As LDE.View
    Dim pColumns As MSXML2.IXMLDOMNodeList
    Dim pColumn As MSXML2.IXMLDOMElement
    Dim strField As String

    Set pColumns = pTableNode.selectNodes("column")
    Set pView = Nothing

    For Each pColumn In pColumns
        If CStr(pColumn.Attributes.getNamedItem("key").nodeValue) = "1" Then
            If pView Is Nothing Then
                Set pView = New LDE.View
            End If
            strField = pColumn.GetAttribute("lime")
            Call pView.Add(strField)
        End If
    Next

    If blnIsSubTable Then
        If Not pView Is Nothing Then
            Call pView.Add(pTableNode.Attributes.getNamedItem("linked").Text & ".id" & strMainTableName)
        End If
    End If

    Set GetView = pView

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetView" & vbCrLf & Err.Source, Err.Description)
End Function

'--------------------------------------------------------
'##SUMMARY Creates dictionary containing views to be used to check if record already in database
'##PARAM pTableNode XML with maintable information
'##PARAM pSubTablesNodeList XML with subtableinformation
'##RETURNS Dictionaty with LDE.View objects. Key is the tablename of Lime
'--------------------------------------------------------
Private Function GetViews(pTableNode As MSXML2.IXMLDOMNode, pSubTablesNodeList As MSXML2.IXMLDOMNodeList) As Scripting.Dictionary
    On Error GoTo ErrorHandler
    Dim pViewCol As New Scripting.Dictionary
    Dim pSubNode As MSXML2.IXMLDOMNode
    Dim strMainTableName As String
    Dim strSubTableName  As String
    Dim strFieldName As String

    strMainTableName = pTableNode.Attributes.getNamedItem("class").Text
    If Not pViewCol.Exists(strMainTableName) Then
        Call pViewCol.Add(strMainTableName, GetView(pTableNode, False, strMainTableName))
    End If

    For Each pSubNode In pSubTablesNodeList
        strSubTableName = pSubNode.Attributes.getNamedItem("class").Text
        strFieldName = pSubNode.Attributes.getNamedItem("field").Text
        If Not pViewCol.Exists(strSubTableName & "." & strFieldName) Then
            Call pViewCol.Add(strSubTableName & "." & strFieldName, GetView(pSubNode, True, strMainTableName))
        End If
    Next

    Set GetViews = pViewCol

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetViews" & vbCrLf & Err.Source, Err.Description)
End Function

'-------------------------------------------
' --- FIELD RULE FUNCTIONS
'-------------------------------------------

Private Sub CheckFieldRules(pImportNode As MSXML2.IXMLDOMNode, pImportLogXML As MSXML2.DOMDocument60, pTableNode As MSXML2.IXMLDOMNode, strTopNode As String, strMainTableName As String)
    On Error GoTo ErrorHandler
    Dim pField As LDE.field
    Dim pNode As MSXML2.IXMLDOMNode
    Dim strTableName As String
    Dim strFieldName As String
    Dim intFieldType As Integer
    Dim strLinkedField As String

    strTableName = pTableNode.Attributes.getNamedItem("class").Text
    strLinkedField = pTableNode.Attributes.getNamedItem("field").Text

    For Each pNode In pTableNode.selectNodes("//table[@class='" & strTableName & "']/column")
        strFieldName = pNode.Attributes.getNamedItem("lime").Text
        intFieldType = pNode.Attributes.getNamedItem("type").Text
        Set pField = Database.Classes(strTableName).Fields(strFieldName)

        'Check format (numeric and date)
        Select Case intFieldType
            Case lkFieldTypeCurrency, lkFieldTypeDecimal, lkFieldTypeGrade, lkFieldTypePercent, lkFieldTypeInteger, lkFieldTypeLink, lkFieldTypeOption, lkFieldTypeYesNo, lkFieldTypeColor:
                If Not pImportNode.Attributes.getNamedItem(strFieldName) Is Nothing Then
                    If Not IsNumeric(pImportNode.Attributes.getNamedItem(strFieldName).Text) Then
                        Call FixNumeric(pImportLogXML, pImportNode, pField, strTableName, strFieldName, strTopNode, strMainTableName, strLinkedField)
                    End If
                End If
            Case lkFieldTypeDate, lkFieldTypeDateFourMonths, lkFieldTypeDateMonth, lkFieldTypeDateQuarter, lkFieldTypeDateSixMonths, lkFieldTypeDateTime, lkFieldTypeDateWeek, lkFieldTypeDateYear, lkFieldTypeTime:
                If Not pImportNode.Attributes.getNamedItem(strFieldName) Is Nothing Then
                    If Not IsDate(pImportNode.Attributes.getNamedItem(strFieldName).Text) Then
                        Call FixDate(pImportLogXML, pImportNode, pField, strTableName, strFieldName, strTopNode, strMainTableName, strLinkedField)
                    End If
                End If
        End Select

        'Check min/max value
        If VBA.Len(pField.Attribute("min")) > 0 Or VBA.Len(pField.Attribute("max")) > 0 Then
            If Not pImportNode.Attributes.getNamedItem(strFieldName) Is Nothing Then
                If pField.Attribute("min") <> "" And CLng(pImportNode.Attributes.getNamedItem(strFieldName).Text) < CLng(pField.Attribute("min")) Then
                    Call FixMinMax(pImportLogXML, pImportNode, pField, strTableName, "min", strTopNode, strMainTableName, strLinkedField)
                ElseIf pField.Attribute("max") <> "" And CLng(pImportNode.Attributes.getNamedItem(strFieldName).Text) > CLng(pField.Attribute("max")) Then
                    Call FixMinMax(pImportLogXML, pImportNode, pField, strTableName, "max", strTopNode, strMainTableName, strLinkedField)
                End If
            End If
        'Check lenght
        ElseIf VBA.Len(pField.Attribute("length")) > 0 Then
            If Not pImportNode.Attributes.getNamedItem(strFieldName) Is Nothing Then
                If VBA.Len(pImportNode.Attributes.getNamedItem(strFieldName).Text) > CLng(pField.Attribute("length")) Then
                    Call FixLength(pImportLogXML, pImportNode, pField, strTableName, strTopNode, strMainTableName, strLinkedField)
                End If
            End If
        End If
    Next

    Exit Sub
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CheckFieldRules" & vbCrLf & Err.Source, Err.Description)
End Sub

'-----------------------------------------------
' ##SUMMARY Correct a value that is too long
' ##PARAM pImportLogXML XML containing server rule errors
' ##PARAM pChildNode Childnode in the pXMLDoc where the invalid value has been found
' ##PARAM strClassname Name of Lime class
' ##REMARKS True if successful
'-----------------------------------------------
Private Function FixLength(pImportLogXML As MSXML2.DOMDocument60, ByRef pChildNode As MSXML2.IXMLDOMNode, pField As LDE.field, strClassName As String, strTopNode As String, strMainTableName As String, strLinkedField As String) As Boolean
    On Error GoTo ErrorHandler
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim strReplaceValue As String
    Dim strOriginValue As String
    Dim strFieldType As String

    Set pErrorRoot = GetErrorRoot(pImportLogXML, strClassName, strMainTableName, strLinkedField)
    Set pErrorNode = CreateErrorNode("length error", strClassName, pField.Name, pChildNode.Attributes.getNamedItem("id" & strClassName).Text, pImportLogXML, strTopNode)

    If Not pErrorNode Is Nothing Then
        strOriginValue = pChildNode.Attributes.getNamedItem(pField.Name).Text
        strReplaceValue = VBA.Left(pChildNode.Attributes.getNamedItem(pField.Name).Text, pField.Attribute("length"))

        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strReplaceValue, "replacevalue", pImportLogXML))
        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strOriginValue, "originvalue", pImportLogXML))

        pChildNode.Attributes.getNamedItem(pField.Name).Text = strReplaceValue

        Call pErrorRoot.appendChild(pErrorNode)
        FixLength = True
    Else
        FixLength = False
    End If

    Exit Function
ErrorHandler:
    FixLength = False
    Call Err.Raise(Err.Number, "XmlImport::FixLength" & vbCrLf & Err.Source, Err.Description)
End Function

' ##SUMMARY Delete a non-numeric attribute value mapped to a numeric Lime field
' ##PARAM pImportLogXML XML containing server rule errors
' ##PARAM pChildNode Childnode in the pXMLDoc where the invalid value has been found
' ##PARAM strClassname Name of Lime class
' ##REMARKS True if successful
'-----------------------------------------------
Private Function FixNumeric(pImportLogXML As MSXML2.DOMDocument60, ByRef pChildNode As MSXML2.IXMLDOMNode, pField As LDE.field, strTableName As String, strFieldName As String, strTopNode As String, strMainTableName As String, strLinkedField As String) As Boolean
    On Error GoTo ErrorHandler
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim strReplaceValue As String
    Dim strOriginValue As String
    Dim strFieldType As String

    Set pErrorRoot = GetErrorRoot(pImportLogXML, strTableName, strMainTableName, strLinkedField)
    Set pErrorNode = CreateErrorNode("numeric error", strTableName, strFieldName, pChildNode.Attributes.getNamedItem("id" & strTableName).Text, pImportLogXML, strTopNode)

    If Not pErrorNode Is Nothing Then
        strOriginValue = pChildNode.Attributes.getNamedItem(strFieldName).Text
        strReplaceValue = "*DELETED*"

        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strReplaceValue, "replacevalue", pImportLogXML))
        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strOriginValue, "originvalue", pImportLogXML))

        Call pChildNode.Attributes.removeNamedItem(strFieldName)

        Call pErrorRoot.appendChild(pErrorNode)
        FixNumeric = True
    Else
        FixNumeric = False
    End If

    Exit Function
ErrorHandler:
    FixNumeric = False
    Call Err.Raise(Err.Number, "XmlImport::FixNumeric" & vbCrLf & Err.Source, Err.Description)
End Function

' ##SUMMARY Delete a non-date attribute value mapped to a date Lime field
' ##PARAM pImportLogXML XML containing server rule errors
' ##PARAM pChildNode Childnode in the pXMLDoc where the invalid value has been found
' ##PARAM strClassname Name of Lime class
' ##REMARKS True if successful
'-----------------------------------------------
Private Function FixDate(pImportLogXML As MSXML2.DOMDocument60, ByRef pChildNode As MSXML2.IXMLDOMNode, pField As LDE.field, strTableName As String, strFieldName As String, strTopNode As String, strMainTableName As String, strLinkedField As String) As Boolean
    On Error GoTo ErrorHandler
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim strReplaceValue As String
    Dim strOriginValue As String
    Dim strFieldType As String

    Set pErrorRoot = GetErrorRoot(pImportLogXML, strTableName, strMainTableName, strLinkedField)
    Set pErrorNode = CreateErrorNode("date error", strTableName, strFieldName, pChildNode.Attributes.getNamedItem("id" & strTableName).Text, pImportLogXML, strTopNode)

    If Not pErrorNode Is Nothing Then
        strOriginValue = pChildNode.Attributes.getNamedItem(strFieldName).Text
        strReplaceValue = "*DELETED*"

        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strReplaceValue, "replacevalue", pImportLogXML))
        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strOriginValue, "originvalue", pImportLogXML))

        Call pChildNode.Attributes.removeNamedItem(strFieldName)

        Call pErrorRoot.appendChild(pErrorNode)
        FixDate = True
    Else
        FixDate = False
    End If

    Exit Function
ErrorHandler:
    FixDate = False
    Call Err.Raise(Err.Number, "XmlImport::FixDate" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Correct a numeric value that either is too low or too high
' ##PARAM pImportLogXML XML containing server rule errors
' ##PARAM pChildNode Childnode in the pXMLDoc where the invalid value has been found
' ##PARAM strClassname Name of Lime class
' ##PARAM strMinOrMax "min" if it is a min error else "max"
' ##RETURNS True if successful
'-----------------------------------------------
Private Function FixMinMax(pImportLogXML As MSXML2.DOMDocument60, ByRef pChildNode As MSXML2.IXMLDOMNode, pField As LDE.field, strClassName As String, strMinOrMax As String, strTopNode As String, strMainTableName As String, strLinkedField As String) As Boolean
    On Error GoTo ErrorHandler
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute
    Dim strReplaceValue As String
    Dim strOriginValue As String
    Dim strFieldType As String

    Set pErrorRoot = GetErrorRoot(pImportLogXML, strClassName, strMainTableName, strLinkedField)
    Set pErrorNode = CreateErrorNode(strMinOrMax & " error", strClassName, pField.Name, pChildNode.Attributes.getNamedItem("id" & strClassName).Text, pImportLogXML, strTopNode)

    If Not pErrorNode Is Nothing Then
        If strMinOrMax = "min" Then
            strReplaceValue = pField.Attribute("min")
        Else
            strReplaceValue = pField.Attribute("max")
        End If
        strOriginValue = pChildNode.Attributes.getNamedItem(pField.Name).Text

        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strReplaceValue, "replacevalue", pImportLogXML))
        Call pErrorNode.Attributes.setNamedItem(GetAttribute(strOriginValue, "originvalue", pImportLogXML))

        pChildNode.Attributes.getNamedItem(pField.Name).Text = strReplaceValue

        Call pErrorRoot.appendChild(pErrorNode)
        FixMinMax = True
    Else
        FixMinMax = False
    End If

    Exit Function
ErrorHandler:
    FixMinMax = False
    Call Err.Raise(Err.Number, "XmlImport::FixMinMax" & vbCrLf & Err.Source, Err.Description)
End Function


'-------------------------------------------
' --- MANDATORY FIELDS FUNCTIONS
'-------------------------------------------


'-----------------------------------------------
' ##SUMMARY Get value for empty mandatory field
' ##PARAM pField The field from Lime
' ##PARAM strFieldType Type of Lime field
' ##PARAM strReplaceValue Value that will be used in XML sent to Lime.
' ##PARAM strErrorValue Value shown for user as used values in RecoveryLog.htm
' ##RETURNS The value that will be used instead of empty
'-----------------------------------------------
Private Function GetMandatoryDefaultValue(pField As LDE.field, ByRef strFieldType As String, ByRef strReplaceValue As String, ByRef strErrorValue As String) As Boolean
    On Error GoTo ErrorHandler
    Dim i As Integer
    Dim pRecords As LDE.Records
    Dim pRecord As LDE.Record
    Dim pView As LDE.View

    strErrorValue = ""

    If pField.Type = lkFieldTypeYesNo Then
        strFieldType = "yesorno"
        strReplaceValue = "1"
    ElseIf pField.Type = lkFieldTypeCurrency Then
        strFieldType = "currency"
        strReplaceValue = GetNumericMandatoryValue(pField)
    ElseIf pField.Type = lkFieldTypeDate Then
        strFieldType = "datetime"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDateFourMonths Then
        strFieldType = "fourmonth"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDateMonth Then
        strFieldType = "month"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDateQuarter Then
        strFieldType = "quarter"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeColor Then
        strFieldType = "color"
        strFieldType = "color"
        strReplaceValue = 0
        strErrorValue = "Black"
    ElseIf pField.Type = lkFieldTypeDateSixMonths Then
        strFieldType = "sixmonth"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDateTime Then
        strFieldType = "time"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDateWeek Then
        strFieldType = "week"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDateYear Then
        strFieldType = "year"
        strReplaceValue = VBA.CStr(VBA.Now)
    ElseIf pField.Type = lkFieldTypeDecimal Then
        strFieldType = "decimal"
        strReplaceValue = GetNumericMandatoryValue(pField)
    ElseIf pField.Type = lkFieldTypeEMail Then
        strFieldType = "mail"
        strReplaceValue = VBA.Left("not_specified@nothing.com", pField.Length)
    ElseIf pField.Type = lkFieldTypeFax Then
        strFieldType = "fax"
        strReplaceValue = "-"
    ElseIf pField.Type = lkFieldTypeGrade Then
        strFieldType = "grade"
        strReplaceValue = GetNumericMandatoryValue(pField)
    ElseIf pField.Type = lkFieldTypeHistory Then
        strFieldType = "history"
        strReplaceValue = VBA.Left("Not specified", pField.Length)
    ElseIf pField.Type = lkFieldTypeInteger Then
        strFieldType = "integer"
        strReplaceValue = GetNumericMandatoryValue(pField)
    ElseIf pField.Type = lkFieldTypeLink Then
        Set pView = New LDE.View
        Set pRecords = New LDE.Records

        If pField.LinkedField.Class.Label = lkClassLabelCoWorker Then
            If Not Application.ActiveUser.Record Is Null Then
                Set pRecord = Application.ActiveUser.Record
            End If
        End If

        If pRecord Is Nothing Then
            Call pView.Add("id" & pField.LinkedField.Class.Name)
            Call pView.Add("descriptive")
            Call pRecords.Open(Database.Classes(pField.LinkedField.Class.Name), , pView, 1)
        End If

        If pRecords.count > 0 Then
            Set pRecord = pRecords.Item(1)
        End If

        strFieldType = "link"
        'If pRecords.Count > 0 Then
        strErrorValue = pRecord.Description
        strReplaceValue = pRecord.Value("id" & pField.LinkedField.Class.Name)
        'End If
    ElseIf pField.Type = lkFieldTypeMemo Then
        strFieldType = "memo"
        strReplaceValue = VBA.Left("Not specified", pField.Length)
    ElseIf pField.Type = lkFieldTypeOption Then
        strFieldType = "option"
        If pField.options.count > 0 Then
            If VBA.Trim(pField.options.Item(1).Value) <> VBA.Trim(pField.Attribute("defaultvalue")) Then
                strReplaceValue = pField.options.Item(1).Value
                strErrorValue = pField.options.Item(1).Text
            Else
                strReplaceValue = pField.options.Item(pField.options.count).Value
                strErrorValue = pField.options.Item(pField.options.count).Text
            End If
        End If
    ElseIf pField.Type = lkFieldTypePercent Then
        strFieldType = "percent"
        strReplaceValue = GetNumericMandatoryValue(pField)
    ElseIf pField.Type = lkFieldTypePhone Then
        strFieldType = "phone"
        strReplaceValue = "-"
    ElseIf pField.Type = lkFieldTypeSet Then
        strFieldType = "set"
        If pField.options.count > 0 Then
        strReplaceValue = ";" & pField.options.Item(1).Value & ";"
        strErrorValue = pField.options.Item(1).Text
        End If
    ElseIf pField.Type = lkFieldTypeText Then
        strFieldType = "text"
        strReplaceValue = VBA.Left("Not specified", pField.Length)
    ElseIf pField.Type = lkFieldTypeTextOption Then
        strFieldType = "textoption"
        strReplaceValue = VBA.Left("Not specified", pField.Length)
    ElseIf pField.Type = lkFieldTypeTime Then
        strFieldType = "time"
        strReplaceValue = VBA.CStr(VBA.Now())
    ElseIf pField.Type = lkFieldTypeURL Then
        strFieldType = "url"
        strReplaceValue = VBA.Left("-", pField.Length)
    ElseIf pField.Type = lkFieldTypeUser Then
        strFieldType = "user"
        strReplaceValue = Application.ActiveUser.id
    Else
        strFieldType = "else"
        strReplaceValue = VBA.Left("-", pField.Length)
    End If

    If strErrorValue = "" Then
        strErrorValue = strReplaceValue
    End If

    GetMandatoryDefaultValue = True

    Exit Function
ErrorHandler:
    GetMandatoryDefaultValue = False
    Call Err.Raise(Err.Number, "XmlImport::GetMandatoryDefaultValue" & vbCrLf & Err.Source, Err.Description)
End Function


'-----------------------------------------------
' ##SUMMARY Returns mandatory numeric value, if min/max rules exists the function returns the min value else 0 is returned
' ##PARAM pField the field from Lime
' ##RETURNS The min value of the field
'-----------------------------------------------
Private Function GetNumericMandatoryValue(pField As LDE.field) As String
    On Error GoTo ErrorHandler
    Dim strValue As String

    strValue = VBA.CStr(pField.Attribute("min"))
    If VBA.Len(strValue) = 0 Then
        strValue = "0"
    End If

    GetNumericMandatoryValue = strValue
    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::GetNumericMandatoryValue" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Set default value for empty mandatory fields
' ##PARAM pXMLDoc XML containing changes from the client
' ##PARAM pImportLogXML XML containing server rule errors
' ##PARAM pChildNode Childnode in the pXMLDoc where the mandatory field is empty
' ##PARAM strReplaceValue Value used instead of empty value
' ##PARAM strErrorValue Value shown for user as used values in RecoveryLog.htm
' ##PARAM strFieldType which type of field it is
' ##RETURNS the value used instead of empty
'-----------------------------------------------
Private Function MandatoryFieldEmpty(pImportXML As MSXML2.DOMDocument60, pImportLogXML As MSXML2.DOMDocument60, ByRef pChildNode As MSXML2.IXMLDOMNode, pField As LDE.field, strTableName As String, strReplaceValue As String, strErrorValue As String, strFieldType As String, strTopNode As String, strMainTableName As String, strLinkedField As String) As String
    On Error GoTo ErrorHandler
    Dim pErrorNode As MSXML2.IXMLDOMNode
    Dim pErrorRoot As MSXML2.IXMLDOMNode
    Dim pAttribute As MSXML2.IXMLDOMAttribute

    Set pErrorRoot = GetErrorRoot(pImportLogXML, strTableName, strMainTableName, strLinkedField)
    Set pErrorNode = CreateErrorNode("empty mandatory field", strTableName, pField.Name, pChildNode.Attributes.getNamedItem("id" & strTableName).Text, pImportLogXML, strTopNode)

    If Not pErrorNode Is Nothing Then
        If strReplaceValue = "" Then
            Call GetMandatoryDefaultValue(pField, strFieldType, strReplaceValue, strErrorValue)
        End If

        If strReplaceValue <> "" Then
            Call pErrorNode.Attributes.setNamedItem(GetAttribute(strFieldType, "fieldtype", pImportLogXML))
            Call pErrorNode.Attributes.setNamedItem(GetAttribute(strErrorValue, "replacevalue", pImportLogXML))

            If pChildNode.Attributes.getNamedItem(pField.Name) Is Nothing Then
                Call pChildNode.Attributes.setNamedItem(GetAttribute(strReplaceValue, pField.Name, pImportLogXML))
            Else
                pChildNode.Attributes.getNamedItem(pField.Name).Text = strReplaceValue
            End If
        End If

        Call pErrorRoot.appendChild(pErrorNode)
        MandatoryFieldEmpty = strReplaceValue
    Else
        MandatoryFieldEmpty = ""
    End If

    Exit Function
ErrorHandler:
    MandatoryFieldEmpty = ""
    Call Err.Raise(Err.Number, "XmlImport::MandatoryFieldEmpty" & vbCrLf & Err.Source, Err.Description)
End Function

'-----------------------------------------------
' ##SUMMARY Check if all mandatory fields have values for new records. If not, it will be set with a
'-----------------------------------------------
Private Function CheckAndFixMandatoryRules(ByVal pImportXML As MSXML2.IXMLDOMElement, strTableName As String, strTopNode As String, pImportLogXML As MSXML2.DOMDocument60, strMainTableName As String, strLinkedField As String) As Boolean
    On Error GoTo ErrorHandler
    Dim pNode As MSXML2.IXMLDOMNode
    Dim strReplaceValue As String
    Dim strErrorValue As String
    Dim strFieldType As String
    Dim pField As LDE.field
    Dim pChildNode As MSXML2.IXMLDOMNode
    Dim strValue As String

    If pImportXML.selectNodes("//" & strTopNode & "/" & strTableName & "[@id" & strTableName & " < 0]").Length > 0 Then
        For Each pField In Database.Classes(strTableName).Fields
            If pField.Required Then
                strErrorValue = ""
                strFieldType = ""
                strReplaceValue = ""
                For Each pChildNode In pImportXML.selectNodes("//" & strTopNode & "/" & strTableName & "[@id" & strTableName & " < 0]")
                    If pChildNode.Attributes.getNamedItem(pField.Name) Is Nothing Then
                        strValue = MandatoryFieldEmpty(pImportXML.ownerDocument, pImportLogXML, pChildNode, pField, strTableName, strReplaceValue, strErrorValue, strFieldType, strTopNode, strMainTableName, strLinkedField)
                    ElseIf pChildNode.Attributes.getNamedItem(pField.Name).Text = "" Then
                        strValue = MandatoryFieldEmpty(pImportXML.ownerDocument, pImportLogXML, pChildNode, pField, strTableName, strReplaceValue, strErrorValue, strFieldType, strTopNode, strMainTableName, strLinkedField)
                    End If
                Next
            End If
        Next
    End If

    CheckAndFixMandatoryRules = True

    Exit Function
ErrorHandler:
    Call Err.Raise(Err.Number, "XmlImport::CheckAndFixMandatoryRules" & vbCrLf & Err.Source, Err.Description)
    CheckAndFixMandatoryRules = False
End Function

Public Sub SaveLogFile(strHTML As String)
    Dim pDialog As LCO.FileSaveDialog
    Dim strFilePath As String
    Dim strHtmlToFile As String
    Dim pFso As Scripting.FileSystemObject
    Dim strPathToCss As String
    Dim sFileName As String
    Dim pStream As Scripting.TextStream
    Dim strCssContent As String
    Dim strCssStylesForImportLog As String
    Dim strCssClass As String
    Dim lngStart As Long
    Dim lngEnd As Long

    Set pDialog = New LCO.FileSaveDialog

    pDialog.Caption = Application.GetText("textfileimport", "title", "saveDialog")
    pDialog.Filter = "HTML File (.htm)|*.htm"
    pDialog.DefaultExtension = "HTML File (.htm)|*.htm"

    If pDialog.show = vbOK Then
        strPathToCss = Application.WebFolder & STRLOGFILEPATH & "css\styles.css"
        sFileName = pDialog.FileName
        Set pFso = New Scripting.FileSystemObject
        strHTML = Mid(strHTML, InStr(1, strHTML, "<TABLE "))

        Set pStream = pFso.OpenTextFile(strPathToCss, ForReading)
        strCssContent = pStream.ReadAll
        pStream.Close

        While InStr(1, strCssContent, "BODY#importlog") > 0
            lngStart = InStr(1, strCssContent, "BODY#importlog")
            lngEnd = InStr(lngStart, strCssContent, "}") + 1
            strCssClass = Mid(strCssContent, lngStart, lngEnd - lngStart)
            strCssContent = Replace(strCssContent, strCssClass, "")

            strCssStylesForImportLog = strCssStylesForImportLog & strCssClass & vbCrLf & vbCrLf
        Wend

        strHtmlToFile = "<HTML>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "   <HEAD>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "       <TITLE>" & Application.GetText("textfileimport", "htmltitle", "xmlLog", Now()) & "</TITLE>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "       <STYLE>" & vbCrLf
        strHtmlToFile = strHtmlToFile & strCssStylesForImportLog
        strHtmlToFile = strHtmlToFile & "       </STYLE>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "   </HEAD>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "   <BODY id=""importlog"">" & vbCrLf
        strHtmlToFile = strHtmlToFile & "       <div class=""header"">" & vbCrLf
        strHtmlToFile = strHtmlToFile & "           <div>" & Application.GetText("textfileimport", "header", "xmlLog") & "</div>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "       </div><br/><br/>" & vbCrLf

        strHtmlToFile = strHtmlToFile & strHTML
        strHtmlToFile = strHtmlToFile & "   </BODY>" & vbCrLf
        strHtmlToFile = strHtmlToFile & "</HTML>" & vbCrLf


        Set pStream = pFso.OpenTextFile(sFileName, ForWriting, True, TristateTrue)
        Call pStream.Write(strHtmlToFile)
        Call pStream.Close
    End If

End Sub

Private Sub m_WorkDialog_Cancel()
    If Lime.MessageBox(Application.GetText("textfileimport", "cancelOperation", "workDialog"), vbYesNo + vbQuestion) = vbYes Then
        Application.MousePointer = 0
        m_WorkDialog.cancel = True
    End If
End Sub





